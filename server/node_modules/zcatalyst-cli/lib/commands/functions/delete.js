'use strict';
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ansi_colors_1 = require("ansi-colors");
const path_1 = require("path");
const endpoints_1 = require("../../endpoints");
const error_1 = __importDefault(require("../../error"));
const common_1 = require("../../fn-utils/lib/common");
const command_1 = __importDefault(require("../../internal/command"));
const prompt_1 = __importDefault(require("../../prompt"));
const config_1 = require("../../util_modules/config");
const constants_1 = require("../../util_modules/constants");
const js_1 = require("../../util_modules/js");
const logger_1 = require("../../util_modules/logger");
const option_1 = require("../../util_modules/option");
const project_1 = require("../../util_modules/project");
exports.default = new command_1.default('functions:delete [function_name_or_id]')
    .description('Delete a function from the remote console or the local directory')
    .option('--local', 'delete the functions in local machine.')
    .option('--remote', 'delete the functions in remote console.')
    .needs('auth', [constants_1.SCOPE.projects])
    .needs('config')
    .needs('rc')
    .action((fnTarget) => __awaiter(void 0, void 0, void 0, function* () {
    const { local = 'LOCAL', remote = 'REMOTE' } = {};
    const sourceDir = (0, project_1.resolveProjectPath)(config_1.functionsConfig.source());
    const fnApi = yield (0, endpoints_1.functionsAPI)();
    let localOpt = (0, option_1.getOptionValue)('local', false);
    let remoteOpt = (0, option_1.getOptionValue)('remote', false);
    const choiceArr = [];
    if (localOpt && remoteOpt) {
        throw new error_1.default('local and remote opts specified in the same command', {
            exit: 1,
            errorId: 'FDEL-1',
            arg: [(0, ansi_colors_1.bold)('--local'), (0, ansi_colors_1.bold)('--remote')]
        });
    }
    if (!localOpt && !remoteOpt) {
        const locationAns = yield prompt_1.default.ask(prompt_1.default.question('location', 'Choose a location to get more information', {
            type: 'list',
            choices: [
                prompt_1.default.choice('Catalyst Remote console', {
                    value: remote,
                    short: 'Catalyst Remote console'
                }),
                prompt_1.default.choice('Local machine', {
                    value: local,
                    short: 'Local machine'
                })
            ]
        }));
        if (locationAns.location === remote) {
            remoteOpt = true;
        }
        else {
            localOpt = true;
        }
    }
    if (localOpt) {
        let target = config_1.functionsConfig.targets([]);
        if (target.length === 0) {
            throw new error_1.default('No targets found in local', {
                exit: 0,
                errorId: 'FDEL-2',
                arg: [(0, ansi_colors_1.bold)('catalyst functions:add')]
            });
        }
        if (fnTarget !== undefined) {
            if (!isNaN(parseInt(fnTarget, 10))) {
                throw new error_1.default('cannot use function Id in local', {
                    exit: 1,
                    errorId: 'FDEL-3'
                });
            }
            if (!target.includes(fnTarget)) {
                throw new error_1.default('function not available in local', {
                    exit: 1,
                    errorId: 'FDEL-4',
                    arg: [(0, ansi_colors_1.bold)(fnTarget), (0, ansi_colors_1.bold)(target.map((tar) => '* ' + tar).join('\n'))]
                });
            }
            target = [fnTarget];
        }
        const localTargets = target.map((fn) => (0, project_1.resolveProjectPath)((0, path_1.join)(sourceDir, fn)));
        const localChoices = (yield (0, common_1.refineTargets)(localTargets, false)).map((fn) => {
            if (!fn.valid) {
                (0, logger_1.debug)(`Invalid function target since, ${fn.failure_reason}.`);
            }
            const name = js_1.JS.isEmpty(fn.name) ? (0, path_1.basename)(fn.source) : fn.name;
            let cStr = (0, ansi_colors_1.bold)(name);
            cStr =
                fn.type === undefined
                    ? cStr
                    : cStr.concat(' -- ', constants_1.REMOTE_REF.functions.type[fn.type]);
            cStr = fn.stack === undefined ? cStr : cStr.concat(' -- ', fn.stack);
            return prompt_1.default.choice(cStr, {
                value: {
                    stack: fn.stack,
                    name,
                    type: fn.type,
                    source: fn.source,
                    location: local
                },
                short: name
            });
        });
        if (localChoices.length > 0) {
            localChoices.unshift(prompt_1.default.separator('-------LOCAL-------'));
        }
        choiceArr.push(...localChoices);
    }
    if (remoteOpt) {
        let remoteTargets = (yield fnApi.getAllFunctions());
        if (js_1.JS.isEmpty(remoteTargets)) {
            throw new error_1.default('No targets found in remote', {
                exit: 0,
                errorId: 'FDEL-5',
                arg: [(0, ansi_colors_1.bold)('catalyst deploy')]
            });
        }
        if (fnTarget !== undefined) {
            const target = parseInt(fnTarget, 10)
                ? remoteTargets.find((fn) => fn.id + '' === fnTarget)
                : remoteTargets.find((fn) => fn.name === fnTarget);
            if (target === undefined) {
                throw new error_1.default('Target not found in remote', {
                    exit: 1,
                    errorId: 'FDEL-6',
                    arg: [
                        (0, ansi_colors_1.bold)(fnTarget),
                        (0, ansi_colors_1.bold)(remoteTargets
                            .map((rTarget) => '* ' + rTarget.name + ' -- ' + rTarget.id)
                            .join('\n'))
                    ]
                });
            }
            remoteTargets = [target];
        }
        const remoteChoices = remoteTargets.map((fn) => {
            const name = fn.name;
            fn.type =
                fn.type === constants_1.REMOTE_REF.functions.type[constants_1.FN_TYPE.applogic]
                    ? constants_1.REMOTE_REF.functions.type[constants_1.FN_TYPE.advanced]
                    : fn.type;
            return prompt_1.default.choice(`${(0, ansi_colors_1.bold)(name)} -- ${fn.type} -- ${fn.stack}`, {
                value: {
                    id: fn.id + '',
                    stack: fn.stack,
                    name,
                    type: fn.type,
                    location: remote
                },
                short: name
            });
        });
        if (remoteChoices.length > 0) {
            remoteChoices.unshift(prompt_1.default.separator('-------REMOTE------'));
        }
        choiceArr.push(...remoteChoices);
    }
    if (js_1.JS.isEmpty(choiceArr)) {
        throw new error_1.default('No functions available to delete', { exit: 2 });
    }
    const fnAns = yield prompt_1.default.ask(prompt_1.default.question('functions', 'Select all the functions needed to be deleted:', {
        type: 'checkbox',
        choices: choiceArr,
        validate: (ansArr) => {
            if (js_1.JS.isEmpty(ansArr)) {
                return 'Select atleast one function to delete!!!';
            }
            return true;
        },
        when: () => choiceArr.length > 2,
        pageSize: 15
    }));
    const fnToDelete = fnAns.functions !== undefined ? fnAns.functions : [choiceArr[1].value];
    const consentAns = yield prompt_1.default.ask(prompt_1.default.question('consent', `Are you sure you want to delete the functions: ${fnToDelete
        .map((fn) => `${fn.name}(${fn.location})`)
        .join(',')}`, {
        type: 'confirm',
        defaultAns: false
    }));
    if (!consentAns.consent) {
        (0, logger_1.message)('Aborted by user');
        return;
    }
    yield Promise.all(fnToDelete.map((fn) => {
        if (fn.location === remote && fn.id !== undefined) {
            return fnApi.delete(fn.id + '');
        }
        else {
            if (fn.source) {
                return (0, common_1.deleteFunctionLocal)(fn.source);
            }
        }
        return;
    }));
    (0, logger_1.info)();
    (0, logger_1.success)('Functions delete completed!');
}));
