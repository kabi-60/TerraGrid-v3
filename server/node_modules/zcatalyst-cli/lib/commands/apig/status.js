'use strict';
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ansi_colors_1 = require("ansi-colors");
const cli_table_1 = __importDefault(require("../../cli_table"));
const endpoints_1 = require("../../endpoints");
const error_1 = __importDefault(require("../../error"));
const command_1 = __importDefault(require("../../internal/command"));
const throbber_1 = __importDefault(require("../../throbber"));
const constants_1 = require("../../util_modules/constants");
const logger_1 = require("../../util_modules/logger");
const option_1 = require("../../util_modules/option");
exports.default = new command_1.default('apig:status')
    .description('Obtain the current status of API Gateway for your project and the schedule progress')
    .option('--previous', 'show previous schedule status instead of current one')
    .needs('auth', [constants_1.SCOPE.projects])
    .needs('config')
    .needs('rc')
    .action(() => __awaiter(void 0, void 0, void 0, function* () {
    const api = yield (0, endpoints_1.apigAPI)();
    const apigStatus = (yield api.getAPIGStatus());
    if (!apigStatus.status) {
        (0, logger_1.info)(`${(0, ansi_colors_1.bold)('API Gateway')}: ${(0, ansi_colors_1.red)('DISABLED')}`);
        (0, logger_1.info)();
        return;
    }
    (0, logger_1.info)(`${(0, ansi_colors_1.bold)('API Gateway')}: ${(0, ansi_colors_1.green)('ENABLED')}`);
    const previousOpt = (0, option_1.getOptionValue)('previous', false);
    if (apigStatus.scheduled === false && !previousOpt) {
        return;
    }
    (0, logger_1.info)();
    let report;
    try {
        report = (yield api.getScheduleReport(previousOpt));
    }
    catch (e) {
        const err = error_1.default.getErrorInstance(e);
        if (err.status && err.status === 404) {
            throw new error_1.default('There is no report available.', {
                exit: 0,
                errorId: 'STAT-1'
            });
        }
        throw err;
    }
    const spinner = 'API Gateway Upsert';
    const throbber = throbber_1.default.getInstance();
    throbber.add(spinner);
    const getSpinnerTxt = (mainTable, failTable) => {
        const spaceRpt = ' '.repeat(35);
        let spinnerTxt = '\n' + spaceRpt;
        spinnerTxt += mainTable
            .toString()
            .split('\n')
            .join('\n' + spaceRpt);
        spinnerTxt += '\n';
        if (failTable.length > 0) {
            failTable.unshift([
                { hAlign: 'center', content: ansi_colors_1.cyan.bold('Name') },
                { hAlign: 'center', content: ansi_colors_1.cyan.bold('Operation') },
                { hAlign: 'center', content: ansi_colors_1.cyan.bold('Reason') },
                { hAlign: 'center', content: ansi_colors_1.cyan.bold('Code') }
            ]);
            failTable.unshift([
                { hAlign: 'center', colSpan: 4, content: ansi_colors_1.red.bold('Failure Details') }
            ]);
            spinnerTxt += failTable.toString() + '\n';
        }
        return spinnerTxt;
    };
    const spinnerFn = (resolve, reject) => __awaiter(void 0, void 0, void 0, function* () {
        let needIteration = true;
        const reportMainTable = new cli_table_1.default();
        const failureTable = new cli_table_1.default();
        reportMainTable.push(['Total Rules', report.total]);
        ['create', 'update', 'delete'].forEach((operation) => {
            const operationObj = report[operation];
            if (operationObj) {
                reportMainTable.push([
                    {
                        hAlign: 'center',
                        colSpan: 2,
                        content: ansi_colors_1.cyan.bold(operation.toUpperCase())
                    }
                ]);
                if (operationObj.success_count > 0) {
                    reportMainTable.push(['Success Count', operationObj.success_count]);
                }
                if (operationObj.fail_count > 0) {
                    reportMainTable.push(['Failure Count', operationObj.fail_count]);
                    operationObj.fail_details.forEach((detail) => {
                        var _a;
                        failureTable.push([
                            detail.name,
                            operation,
                            ((_a = detail.reason.match(/.{1,50}/g)) === null || _a === void 0 ? void 0 : _a.join('\n')) || '-NA-',
                            detail.code
                        ]);
                    });
                }
            }
        });
        switch (report.state) {
            case 0:
                reportMainTable.unshift([
                    {
                        hAlign: 'center',
                        colSpan: 2,
                        content: ansi_colors_1.yellow.bold('Yet to start')
                    }
                ]);
                break;
            case 1:
                reportMainTable.unshift([
                    {
                        hAlign: 'center',
                        colSpan: 2,
                        content: ansi_colors_1.yellow.bold('Creating APIs')
                    }
                ]);
                break;
            case 2:
                reportMainTable.unshift([
                    {
                        hAlign: 'center',
                        colSpan: 2,
                        content: ansi_colors_1.yellow.bold('Updating APIs')
                    }
                ]);
                break;
            case 3:
                reportMainTable.unshift([
                    {
                        hAlign: 'center',
                        colSpan: 2,
                        content: ansi_colors_1.yellow.bold('Deleting APIs')
                    }
                ]);
                break;
            case 4:
                reportMainTable.unshift([
                    { hAlign: 'center', colSpan: 2, content: ansi_colors_1.green.bold('Completed') }
                ]);
                throbber.succeed(spinner, {
                    text: getSpinnerTxt(reportMainTable, failureTable)
                });
                needIteration = false;
                resolve();
                break;
            case 5:
                reportMainTable.unshift([
                    {
                        colSpan: 2,
                        content: report.error
                    }
                ]);
                reportMainTable.unshift([
                    {
                        hAlign: 'center',
                        colSpan: 2,
                        content: ansi_colors_1.red.bold('ERROR')
                    }
                ]);
                throbber.fail(spinner, {
                    text: getSpinnerTxt(reportMainTable, failureTable)
                });
                needIteration = false;
                resolve();
                break;
            default:
                needIteration = false;
                reject(new error_1.default('unknown state received', { exit: 2 }));
                break;
        }
        if (report.state !== 4 && report.state !== 5) {
            throbber.update(spinner, {
                text: getSpinnerTxt(reportMainTable, failureTable) +
                    'Press CTRL + C to exit listening to the status'
            });
            try {
                report = (yield api.getScheduleReport(false));
            }
            catch (ex) {
                const err = error_1.default.getErrorInstance(ex);
                if (err.status && err.status === 404) {
                    report = (yield api.getScheduleReport(true));
                }
                else {
                    throbber.stopAll();
                    needIteration = false;
                    reject(err);
                }
            }
        }
        if (needIteration) {
            setTimeout(() => spinnerFn(resolve, reject), 2000);
        }
    });
    return new Promise((resolve, reject) => __awaiter(void 0, void 0, void 0, function* () { return spinnerFn(resolve, reject); }));
}));
