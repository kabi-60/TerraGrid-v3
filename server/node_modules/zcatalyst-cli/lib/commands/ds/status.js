'use strict';
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ansi_colors_1 = require("ansi-colors");
const path_1 = require("path");
const cli_table_1 = __importDefault(require("../../cli_table"));
const endpoints_1 = require("../../endpoints");
const error_1 = __importDefault(require("../../error"));
const command_1 = __importDefault(require("../../internal/command"));
const prompt_1 = __importDefault(require("../../prompt"));
const throbber_1 = __importDefault(require("../../throbber"));
const constants_1 = require("../../util_modules/constants");
const fs_1 = require("../../util_modules/fs");
const logger_1 = require("../../util_modules/logger");
const option_1 = require("../../util_modules/option");
const getSpinnerTxt = (mainTable, finalReport) => {
    var _a, _b, _c, _d;
    const spaceRpt = ' '.repeat(35);
    let spinnerTxt = '\n' + spaceRpt;
    spinnerTxt += mainTable
        .toString()
        .split('\n')
        .join('\n' + spaceRpt);
    spinnerTxt += '\n';
    if (finalReport === undefined) {
        return spinnerTxt;
    }
    if (finalReport.status === 'Completed') {
        spinnerTxt += (0, ansi_colors_1.green)(((_a = finalReport.results) === null || _a === void 0 ? void 0 : _a.description) + '');
        if (((_b = finalReport.results) === null || _b === void 0 ? void 0 : _b.download_url) !== undefined) {
            spinnerTxt += '\n';
            spinnerTxt += (0, ansi_colors_1.bold)(`Download URL : ${(_c = finalReport.results) === null || _c === void 0 ? void 0 : _c.download_url}`);
        }
    }
    else {
        spinnerTxt += (0, ansi_colors_1.red)((0, ansi_colors_1.bold)('Reason : ') + ((_d = finalReport.results) === null || _d === void 0 ? void 0 : _d.description));
    }
    return spinnerTxt;
};
const spinnerFn = (jobId, dsReport, cumulativeStatus, throbber, spinner, bulkApi, displayOpr, action) => (resolve, reject) => __awaiter(void 0, void 0, void 0, function* () {
    if (jobId === undefined) {
        reject('Job Id cannot be empty!');
        return;
    }
    let needIteration = true;
    const reportTable = new cli_table_1.default();
    Object.keys(cumulativeStatus).forEach((table) => {
        const initialCount = reportTable.length;
        let tableRowCount = reportTable.length;
        ['insert', 'update', 'upsert', 'read'].forEach((statusAct) => {
            const operationObj = cumulativeStatus[table][statusAct];
            if (operationObj !== null && operationObj !== undefined) {
                let operationRowCount = 0;
                if (operationObj.rows_processed !== undefined &&
                    operationObj.rows_processed >= 0) {
                    reportTable[tableRowCount++] = [
                        'Processed',
                        operationObj.rows_processed + ''
                    ];
                    operationRowCount++;
                }
                if (operationObj.fail_count !== undefined && operationObj.fail_count >= 0) {
                    reportTable[tableRowCount++] = ['Failure', operationObj.fail_count + ''];
                    operationRowCount++;
                }
                if (operationRowCount > 0) {
                    reportTable[tableRowCount - operationRowCount].unshift({
                        hAlign: 'center',
                        vAlign: 'center',
                        rowSpan: operationRowCount,
                        content: statusAct.toUpperCase()
                    });
                }
            }
        });
        if (tableRowCount > 0) {
            reportTable[initialCount].unshift({
                hAlign: 'center',
                vAlign: 'center',
                rowSpan: tableRowCount,
                content: ansi_colors_1.cyan.bold(table)
            });
        }
    });
    switch (dsReport.status) {
        case 'In-Progress':
            if (reportTable.length === 0) {
                reportTable.unshift([
                    { hAlign: 'center', content: ansi_colors_1.yellow.bold('Yet to start') }
                ]);
            }
            else {
                reportTable.unshift([
                    {
                        hAlign: 'center',
                        colSpan: 4,
                        content: ansi_colors_1.cyan.bold('In-Progress')
                    }
                ]);
            }
            break;
        case 'Completed':
            reportTable.unshift([
                {
                    hAlign: 'center',
                    colSpan: 4,
                    content: ansi_colors_1.green.bold(displayOpr + ' Job Completed')
                }
            ]);
            dsReport = (yield bulkApi.getReport(action, jobId));
            throbber.succeed(spinner, {
                text: getSpinnerTxt(reportTable, dsReport)
            });
            needIteration = false;
            resolve(dsReport);
            break;
        case 'Failed':
            reportTable.unshift([
                {
                    hAlign: 'center',
                    content: ansi_colors_1.red.bold(displayOpr + ' Job Failed!')
                }
            ]);
            dsReport = (yield bulkApi.getReport(action, jobId));
            throbber.fail(spinner, {
                text: getSpinnerTxt(reportTable, dsReport)
            });
            needIteration = false;
            resolve(dsReport);
            break;
        default:
            needIteration = false;
            reject(new error_1.default('unknown state received', { exit: 2 }));
            break;
    }
    if (dsReport.status === 'In-Progress') {
        throbber.update(spinner, {
            text: getSpinnerTxt(reportTable) + 'Press CTRL + C to exit listening to the status'
        });
        try {
            cumulativeStatus = (yield bulkApi.getStatus(action, jobId));
            if (Object.keys(cumulativeStatus).length === 0) {
                dsReport = (yield bulkApi.getReport(action, jobId));
                if (dsReport.status === 'Completed') {
                    cumulativeStatus = (yield bulkApi.getStatus(action, jobId, true));
                }
            }
        }
        catch (ex) {
            throbber.stopAll();
            needIteration = false;
            reject(ex);
        }
    }
    if (needIteration) {
        setTimeout(() => spinnerFn(jobId, dsReport, cumulativeStatus, throbber, spinner, bulkApi, displayOpr, action)(resolve, reject), 2000);
    }
});
exports.default = new command_1.default('ds:status <operation> [jobid]')
    .description('Display the job status of a Data Store import or export operation')
    .option('--production', 'flag for pointing to production environment.')
    .needs('auth', [constants_1.SCOPE.projects, constants_1.SCOPE.datastore, constants_1.SCOPE.row])
    .needs('config', { optional: true })
    .needs('rc', { optional: true })
    .action((operation, jobId) => __awaiter(void 0, void 0, void 0, function* () {
    const env = (0, option_1.getOptionValue)('production', false) ? 'Production' : 'Development';
    const action = operation === 'import' ? 'write' : 'read';
    const displayOpr = operation === 'import' ? 'Import' : 'Export';
    const bulkApi = yield (0, endpoints_1.bulkDSAPI)({ env });
    if (jobId === undefined) {
        const jobsList = (yield bulkApi.getAllJobs(action));
        if (jobsList === undefined || jobsList.length === 0) {
            throw new error_1.default('No jobs available', {
                exit: 0,
                errorId: 'STAT-1',
                arg: [(0, ansi_colors_1.bold)('ds:import or ds:export')]
            });
        }
        const listTable = new cli_table_1.default();
        listTable.push(['Job ID', 'Table Name', 'Created Time', 'Created By', 'Status']);
        const choices = jobsList.map((jobDetails) => {
            var _a;
            listTable.push([
                jobDetails.job_id,
                jobDetails.tableName,
                jobDetails.created_time,
                (_a = jobDetails.created_by) === null || _a === void 0 ? void 0 : _a.email_id,
                jobDetails.status
            ]);
            return prompt_1.default.choice(`${jobDetails.job_id} - (${jobDetails.tableName})`, {
                value: jobDetails.job_id
            });
        });
        (0, logger_1.info)('List of ' + displayOpr + ' Jobs :');
        (0, logger_1.info)(listTable.toString());
        const jobAns = yield prompt_1.default.ask(prompt_1.default.question('job', `Select an ${operation} job id, to view detailed status : `, {
            type: 'list',
            choices
        }));
        jobId = jobAns.job;
    }
    if (jobId === undefined) {
        throw new error_1.default('Job ID is empty!', { exit: 2 });
    }
    const dsReport = (yield bulkApi.getReport(action, jobId).catch((err) => {
        if (err.status === 404) {
            throw new error_1.default('No jobs found for the given id', {
                exit: 1,
                errorId: 'STAT-2',
                arg: [(0, ansi_colors_1.bold)(jobId), (0, ansi_colors_1.bold)('catalyst ds:status ' + operation)]
            });
        }
        throw err;
    }));
    let cumulativeStatus;
    cumulativeStatus = (yield bulkApi.getStatus(action, jobId));
    if (Object.keys(cumulativeStatus).length === 0) {
        cumulativeStatus = (yield bulkApi.getStatus(action, jobId, true));
    }
    const spinner = 'DS bulk ' + operation;
    const throbber = throbber_1.default.getInstance();
    throbber.add(spinner);
    const finalDsReport = yield new Promise(spinnerFn(jobId, dsReport, cumulativeStatus, throbber, spinner, bulkApi, displayOpr, action));
    if (finalDsReport.results && finalDsReport.results.download_url) {
        const ans = yield prompt_1.default.ask(prompt_1.default.question('download', 'Do you like to download the report of this job to your cmd execution directory?', { type: 'confirm', defaultAns: false }));
        if (ans.download) {
            const hrTime = process.hrtime();
            const fileName = `${displayOpr}_${jobId}_${hrTime[0] * 1000000000 + hrTime[1]}.zip`;
            const bulkReport = (yield bulkApi.downloadReport(finalDsReport.results.download_url, fileName));
            return fs_1.ASYNC.writeFile((0, path_1.join)(process.cwd(), fileName), bulkReport);
        }
    }
}));
