'use strict';
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ansi_colors_1 = require("ansi-colors");
const path_1 = require("path");
const client_utils_1 = require("../../client-utils");
const endpoints_1 = require("../../endpoints");
const error_1 = __importDefault(require("../../error"));
const command_1 = __importDefault(require("../../internal/command"));
const prompt_1 = __importDefault(require("../../prompt"));
const runtime_store_1 = __importDefault(require("../../runtime-store"));
const config_1 = require("../../util_modules/config");
const constants_1 = require("../../util_modules/constants");
const fs_1 = require("../../util_modules/fs");
const js_1 = require("../../util_modules/js");
const logger_1 = require("../../util_modules/logger");
const option_1 = require("../../util_modules/option");
const project_1 = require("../../util_modules/project");
exports.default = new command_1.default('client:delete [client_version]')
    .description('Delete a version of the client from the remote console or the local directory')
    .option('--local', 'removes the client from local machine')
    .option('--remote', 'removes the selected client from remote console')
    .needs('auth', [constants_1.SCOPE.webapp])
    .needs('config')
    .needs('rc')
    .action((clientVersion) => __awaiter(void 0, void 0, void 0, function* () {
    const { local = 'LOCAL', remote = 'REMOTE' } = {};
    const clientDir = (0, project_1.resolveProjectPath)(config_1.clientConfig.source());
    const clientApi = yield (0, endpoints_1.clientAPI)();
    let localOpt = (0, option_1.getOptionValue)('local', false);
    let remoteOpt = (0, option_1.getOptionValue)('remote', false);
    const appsToBeDeleted = [];
    if (localOpt && remoteOpt) {
        throw new error_1.default('both options specified', {
            exit: 1,
            errorId: 'CDEL-1',
            arg: [(0, ansi_colors_1.bold)('--local'), (0, ansi_colors_1.bold)('--remote')]
        });
    }
    if (!localOpt && !remoteOpt) {
        const locationAns = yield prompt_1.default.ask(prompt_1.default.question('location', 'Choose a location to get more information', {
            type: 'list',
            choices: [
                prompt_1.default.choice('Catalyst Remote console', {
                    value: remote,
                    short: 'Catalyst Remote console'
                }),
                prompt_1.default.choice('Local machine', {
                    value: local,
                    short: 'Local machine'
                })
            ]
        }));
        if (locationAns.location === remote) {
            remoteOpt = true;
        }
        else {
            localOpt = true;
        }
    }
    if (localOpt) {
        const dirExists = yield fs_1.ASYNC.dirExists(clientDir);
        if (dirExists) {
            const packageJsonFile = (0, path_1.join)(clientDir, constants_1.FILENAME.client.package_json);
            const localDel = {
                location: local
            };
            try {
                const configFile = fs_1.ASYNC.readJSONFile(packageJsonFile, {
                    checkpath: true
                });
                if (configFile === undefined) {
                    throw new error_1.default('File not found', { exit: 2 });
                }
                const version = js_1.JS.get(configFile, 'version', '[unknown]');
                localDel.version = version;
            }
            catch (error) {
                const err = error_1.default.getErrorInstance(error);
                err.exit = 2;
                (0, logger_1.debug)('Failed to read ' + constants_1.FILENAME.client.package_json + ' Reason: ' + err.message);
            }
            if (clientVersion !== undefined && clientVersion !== localDel.version) {
                throw new error_1.default('version unavailable in local', {
                    exit: 1,
                    errorId: 'CDEL-2',
                    arg: [(0, ansi_colors_1.bold)(localDel.version)]
                });
            }
            appsToBeDeleted.push(localDel);
        }
        else {
            const conf = runtime_store_1.default.get('config');
            if (conf.get('client') !== undefined) {
                (0, logger_1.debug)('No client directory found. Removing the entry for client in ' +
                    constants_1.FILENAME.config);
                conf.unset('client');
                yield conf.save();
            }
            throw new error_1.default('No client directory found in local', {
                exit: 0,
                errorId: 'CDEL-3',
                arg: [(0, ansi_colors_1.bold)('catalyst client:setup')]
            });
        }
    }
    if (remoteOpt) {
        const choicesArray = [];
        let historyArr = (yield clientApi.getAllHistory());
        if (js_1.JS.isEmpty(historyArr)) {
            throw new error_1.default('No clients available', {
                exit: 0,
                errorId: 'CDEL-4',
                arg: [(0, ansi_colors_1.bold)('catalyst deploy --only client')]
            });
        }
        if (clientVersion !== undefined) {
            const ipVersion = js_1.JS.find(historyArr, (history) => history.app_version === clientVersion);
            if (ipVersion === undefined) {
                const avlVer = historyArr
                    .filter((his) => {
                    const status = js_1.JS.get(his, 'status', false);
                    return !status;
                })
                    .map((his) => {
                    return '* ' + his.app_version;
                });
                throw new error_1.default('Version unavailble in remote', {
                    exit: 1,
                    errorId: 'CDEL-5',
                    arg: [
                        (0, ansi_colors_1.bold)(clientVersion),
                        (0, ansi_colors_1.bold)(avlVer.length > 0 ? avlVer.join('\n') : 'None')
                    ]
                });
            }
            if (ipVersion.status) {
                throw new error_1.default('attempt to delete a live web client', {
                    exit: 0,
                    errorId: 'CDEL-6',
                    arg: [(0, ansi_colors_1.bold)(ipVersion.app_version)]
                });
            }
            historyArr = [ipVersion];
        }
        choicesArray.push(prompt_1.default.separator('-------REMOTE-------'));
        js_1.JS.forEach(historyArr, (history) => {
            const version = js_1.JS.get(history, 'status', false)
                ? `${history.app_version} (${(0, ansi_colors_1.cyan)('live')})`
                : `${history.app_version}`;
            choicesArray.push(prompt_1.default.choice(`${version}`, {
                value: {
                    id: history.history_id,
                    version: history.app_version,
                    location: remote
                },
                short: history.app_version,
                disabled: js_1.JS.get(history, 'status', false)
                    ? 'live client cannot be deleted'
                    : false
            }));
        });
        const choiceAns = yield prompt_1.default.ask(prompt_1.default.question('choice', 'Select all the client versions you want to delete', {
            type: 'checkbox',
            choices: choicesArray,
            validate: (answers) => {
                if (answers !== undefined && answers.length > 0) {
                    return true;
                }
                return 'Select atleast one version to delete !!!';
            },
            when: () => {
                return choicesArray.length > 2;
            }
        }));
        if (choiceAns.choice !== undefined) {
            appsToBeDeleted.push(...choiceAns.choice);
        }
        else if (choicesArray.length === 2 && !choicesArray[1].disabled) {
            appsToBeDeleted.push(choicesArray[1].value);
        }
        else if (choicesArray.length === 2 && choicesArray[1].disabled) {
            throw new error_1.default('Only live client available', {
                exit: 1,
                errorId: 'CDEL-7',
                arg: [(0, ansi_colors_1.bold)(historyArr[0].app_version)]
            });
        }
        else {
            throw new error_1.default('No clients selected from remote', { exit: 2 });
        }
    }
    const consentAns = yield prompt_1.default.ask(prompt_1.default.question('consent', 'Are you sure you want to delete the clients : ' +
        appsToBeDeleted.map((app) => `${app.version}(${app.location})`).join(','), {
        type: 'confirm',
        defaultAns: false,
        when: () => {
            return appsToBeDeleted.length > 0;
        }
    }));
    if (!consentAns.consent) {
        (0, logger_1.message)('Aborted by user');
        return;
    }
    yield Promise.all(appsToBeDeleted.map((app) => {
        if (app.location === remote && app.id !== undefined) {
            return clientApi.delete(app.id + '');
        }
        else if (app.location === local) {
            return client_utils_1.clientUtils.deleteClientLocal(clientDir);
        }
        return;
    }));
    (0, logger_1.success)('Catalyst client delete complete!');
}));
