'use strict';
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.filterTargets = exports.filterPorts = void 0;
const ansi_colors_1 = require("ansi-colors");
const error_1 = __importDefault(require("./error"));
const runtime_store_1 = __importDefault(require("./runtime-store"));
const CONFIG = __importStar(require("./util_modules/config"));
const constants_1 = require("./util_modules/constants");
const fs_1 = require("./util_modules/fs");
const js_1 = require("./util_modules/js");
const option_1 = require("./util_modules/option");
const project_1 = require("./util_modules/project");
const onlyExceptTargets = [
    { filterName: ['functions'], target: 'functions' },
    { filterName: ['client'], target: 'client' },
    { filterName: ['apig'], target: 'apig' },
    { filterName: ['appsail'], target: 'appsail' }
];
const portTargets = [
    { filterName: ['appsail'], target: 'appsail' },
    { filterName: ['advancedio', 'aio'], target: 'aio' },
    { filterName: ['basicio', 'bio'], target: 'bio' },
    { filterName: ['client'], target: 'client' },
    { filterName: ['browser_logic', 'browserlogic'], target: 'browserlogic' }
];
function enrichOptsData(opt, optValue, validTargets, multiTargetSupport = true) {
    if (optValue === undefined || typeof optValue === 'boolean') {
        return [];
    }
    return optValue
        .split(',')
        .reduce((accumulator, entry, entryIndex, optArr) => {
        if (optArr.indexOf(entry) !== entryIndex) {
            optArr[entryIndex] = (0, ansi_colors_1.red)(optArr[entryIndex]);
            throw new error_1.default(`Duplicate target found for ${(0, ansi_colors_1.bold)(entry)}.`, {
                exit: 1,
                errorId: 'OPT-FILTER-1',
                arg: [
                    (0, ansi_colors_1.bold)('--' + opt),
                    (0, ansi_colors_1.bold)('Option input: ') + (0, ansi_colors_1.italic)('--' + opt + ' ' + optArr.join(','))
                ]
            });
        }
        const entrySet = entry.split(':');
        const resultantTarget = validTargets.find((targs) => targs.filterName.includes(entrySet[0]));
        if (!resultantTarget) {
            throw new error_1.default(`Invalid target "${entrySet[0]}" specified for option "${opt}".`, {
                exit: 1,
                errorId: 'OPT-FILTER-2',
                arg: [
                    ansi_colors_1.bold.red(entrySet[0]),
                    (0, ansi_colors_1.bold)('--' + opt),
                    (0, ansi_colors_1.bold)(validTargets
                        .map((target) => '* ' + target.filterName.join(' | '))
                        .join('\n'))
                ]
            });
        }
        if (!multiTargetSupport &&
            accumulator.some((res) => res.target.filterName.includes(entrySet[0]))) {
            throw new error_1.default(`Target "${entrySet[0]}" is specified more than once for option "${opt}". Please specify only one.`, {
                exit: 1
            });
        }
        const resultant = {
            hasFilter: false,
            target: resultantTarget
        };
        if (accumulator.some((res, idx) => {
            const truthy = res.target.filterName.includes(entrySet[0]) &&
                ((res.hasFilter && entrySet.length === 1) ||
                    (!res.hasFilter && entrySet.length === 2));
            if (truthy) {
                optArr[idx] = (0, ansi_colors_1.red)(optArr[idx]);
                optArr[entryIndex] = (0, ansi_colors_1.red)(optArr[entryIndex]);
            }
            return truthy;
        })) {
            throw new error_1.default(`Target "${entrySet[0]}" is specified with and without a filter for option "${opt}".`, {
                exit: 1,
                errorId: 'OPT-FILTER-3',
                arg: [
                    ansi_colors_1.bold.red(entrySet[0]),
                    (0, ansi_colors_1.bold)('--' + opt),
                    (0, ansi_colors_1.bold)('Option input: ') + (0, ansi_colors_1.italic)(`--${opt} ${optArr.join(',')}`)
                ]
            });
        }
        if (entrySet.length > 1) {
            resultant.hasFilter = true;
            resultant.filter = entrySet[1];
            if (entrySet.length === 3) {
                resultant.specific = entrySet[2];
            }
        }
        accumulator.push(resultant);
        return accumulator;
    }, []);
}
function validateTargets() {
    if ((0, option_1.getOptionValue)('except', false) && (0, option_1.getOptionValue)('only', false)) {
        throw new error_1.default('Cannot specify both --only and --except', {
            exit: 1,
            errorId: 'OPT-FILTER-4',
            arg: [(0, ansi_colors_1.bold)('--only'), (0, ansi_colors_1.bold)('--except')]
        });
    }
    const enrichedOnlyOpts = enrichOptsData('only', (0, option_1.getOptionValue)('only'), onlyExceptTargets);
    if (enrichedOnlyOpts.length > 0) {
        return enrichedOnlyOpts;
    }
    const enrichedExceptOpts = enrichOptsData('except', (0, option_1.getOptionValue)('except'), onlyExceptTargets);
    if (enrichedExceptOpts.length > 0) {
        return enrichedExceptOpts;
    }
    return [];
}
function validatePorts() {
    const customHttpPort = (0, option_1.getOptionValue)('http', undefined);
    const enrichedDebugOpts = enrichOptsData('debug', (0, option_1.getOptionValue)('debug'), portTargets);
    if (enrichedDebugOpts.some((opt) => {
        const noFilter = !opt.hasFilter;
        if (opt.target.target === 'client') {
            throw new error_1.default('Client cannot be debugged', {
                exit: 1,
                errorId: 'OPT-FILTER-5'
            });
        }
        return noFilter;
    })) {
        throw new error_1.default('Cannot specify "--debug <target>" alone.', {
            exit: 1,
            errorId: 'OPT-FILTER-6',
            arg: [
                (0, ansi_colors_1.bold)('--debug'),
                ansi_colors_1.italic.red('--debug <target>'),
                (0, ansi_colors_1.bold)('* basicio: ') + ansi_colors_1.italic.green('--debug <basicio|bio>:<port>'),
                (0, ansi_colors_1.bold)('* advancedio: ') + ansi_colors_1.italic.green('--debug <advancedio|aio>:<name>:<port>'),
                (0, ansi_colors_1.bold)('* browserlogic: ') +
                    ansi_colors_1.italic.green('--debug <browserlogic|browser_logic>:<name>:<port>')
            ]
        });
    }
    return {
        port: customHttpPort,
        debug: enrichedDebugOpts
    };
}
function filterPorts() {
    const validOptResultants = validatePorts();
    runtime_store_1.default.set(`context.port.http.master`, validOptResultants.port);
    validOptResultants.debug.forEach((res) => {
        if ((res.target.target === constants_1.FN_TYPE.advanced ||
            res.target.target === constants_1.FN_TYPE.browserLogic) &&
            !res.specific) {
            const targMap = {
                aio: {
                    filter: 'advancedio|aio',
                    targName: constants_1.REMOTE_REF.functions.type[res.target.target]
                },
                browserlogic: {
                    filter: 'browser_logic|browserlogic',
                    targName: constants_1.REMOTE_REF.functions.type[res.target.target]
                }
            };
            const targ = targMap[res.target.target];
            throw new error_1.default(`Invalid input format for ${targ} target`, {
                exit: 1,
                errorId: 'OPT-FILTER-7',
                arg: [
                    (0, ansi_colors_1.bold)('--debug'),
                    (0, ansi_colors_1.bold)(targ.targName),
                    ansi_colors_1.italic.red(`--debug <${targ.filter}>:<name|port>`),
                    ansi_colors_1.italic.green(`--debug <${targ.filter}>:<name>:<port>`),
                    targ.targName
                ]
            });
        }
        else if (res.target.target === constants_1.FN_TYPE.basic) {
            runtime_store_1.default.set(`context.port.debug.${constants_1.FN_TYPE.basic}`, res.filter);
        }
        else {
            runtime_store_1.default.set(`context.port.debug.${res.target.target}.${res.filter}`, res.specific);
        }
    });
}
exports.filterPorts = filterPorts;
function filterTargets(pathSense = true) {
    const validTargetResultants = validateTargets();
    const config = runtime_store_1.default.get('config');
    let targets = onlyExceptTargets.filter((t) => config.has(t.target)).map((t) => t.target);
    if (validTargetResultants.length === 0) {
        if (runtime_store_1.default.get('project.root') !== runtime_store_1.default.get('cwd')) {
            targets = targets.filter((target) => {
                if (target === 'appsail') {
                    return true;
                }
                if (target === 'apig' && (0, option_1.getCurrentCommand)() === 'serve') {
                    return true;
                }
                if (!pathSense) {
                    return true;
                }
                const targetRoot = (0, project_1.resolveProjectPath)(CONFIG[(target + 'Config')].source());
                return (fs_1.SYNC.isPathInside(targetRoot, runtime_store_1.default.get('cwd')) ||
                    runtime_store_1.default.get('cwd') === targetRoot);
            });
        }
    }
    else if ((0, option_1.getOptionValue)('only', false)) {
        targets = validTargetResultants.map((resultant) => {
            return resultant.target.target;
        });
    }
    else if ((0, option_1.getOptionValue)('except', false)) {
        const unwantedTargets = validTargetResultants
            .filter((val) => {
            if ((val.target.target === 'functions' || val.target.target === 'appsail') &&
                val.hasFilter) {
                return false;
            }
            return true;
        })
            .map((resultant) => resultant.target.target);
        targets = targets.filter((target) => !unwantedTargets.includes(target));
    }
    targets = js_1.JS.uniq(targets);
    if (targets.length === 0) {
        const aid = (0, option_1.getOptionValue)('except', false)
            ? `the ${(0, ansi_colors_1.bold)('--except')} option does not rule out all the valid targets.`
            : `the desired features are initialised in the ${(0, ansi_colors_1.bold)(constants_1.FILENAME.config)} file.`;
        throw new error_1.default('Cannot understand what targets.', {
            exit: 1,
            errorId: 'OPT-FILTER-8',
            arg: [aid]
        });
    }
    if (targets.length === 1 && targets.includes('apig') && (0, option_1.getCurrentCommand)() === 'serve') {
        throw new error_1.default('API Gateway cannot be served separately', {
            exit: 1,
            errorId: 'OPT-FILTER-9'
        });
    }
    runtime_store_1.default.set('context.targets', targets);
    return targets;
}
exports.filterTargets = filterTargets;
