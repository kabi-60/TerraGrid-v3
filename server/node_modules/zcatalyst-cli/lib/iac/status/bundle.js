"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const iac_1 = __importDefault(require("../../endpoints/lib/iac"));
const api_timer_1 = __importDefault(require("../../api-timer"));
const error_1 = __importDefault(require("../../error"));
const throbber_1 = __importDefault(require("../../throbber"));
const logger_1 = require("../../util_modules/logger");
const util_1 = require("./util");
const prompt_1 = __importDefault(require("../../prompt"));
const fs_1 = require("../../util_modules/fs");
const path_1 = require("path");
const option_1 = require("../../util_modules/option");
exports.default = () => __awaiter(void 0, void 0, void 0, function* () {
    const env = (0, option_1.getOptionValue)('production', false) ? 'Production' : 'Development';
    const getSpinnerTxt = (0, util_1.getSpinnerTxt)('bundle');
    const iacAPI = new iac_1.default(undefined, { env });
    const bundleStatus = yield iacAPI.bundleStatus();
    if (bundleStatus === undefined) {
        throw new error_1.default('No export project available in server.', {
            exit: 1,
            errorId: 'B-1'
        });
    }
    const throbber = throbber_1.default.getInstance();
    const spinner = bundleStatus.id;
    throbber.add(spinner, {
        text: getSpinnerTxt(bundleStatus)
    });
    const timerAPI = new api_timer_1.default(iacAPI.bundleStatus.bind(iacAPI), 2000, 1);
    timerAPI.on('data', (data) => __awaiter(void 0, void 0, void 0, function* () {
        switch (data.status) {
            case 'Scheduled':
            case 'Processing':
                throbber.update(spinner, {
                    text: getSpinnerTxt(data) + '\nPress CTRL + C to exit listening to the status'
                });
                break;
            case 'Error_Processing':
                throbber.fail(spinner, {
                    text: getSpinnerTxt(data, 'failed')
                });
                timerAPI.end();
                break;
            case 'Completed':
                throbber.succeed(spinner, {
                    text: getSpinnerTxt(data)
                });
                timerAPI.end(undefined, true);
                break;
            default:
                (0, logger_1.debug)('Unknown status received : ', data.status);
                timerAPI.end();
        }
    }));
    timerAPI.on('error', (e) => {
        (0, logger_1.debug)('Error encounted :', e);
    });
    timerAPI.on('end', () => throbber.stopAll());
    timerAPI.start();
    const isCompleted = yield timerAPI.waitForEnd();
    if (isCompleted) {
        const ans = yield prompt_1.default.ask(prompt_1.default.question('download', 'Would you like to download the export zip of this job to your cmd execution directory?', { type: 'confirm', defaultAns: true }));
        if (ans.download) {
            const hrTime = process.hrtime();
            const fileName = `export_${bundleStatus.id}_${hrTime[0] * 1000000000 + hrTime[1]}.zip`;
            const bundlezip = yield iacAPI.bundleDownload();
            return fs_1.ASYNC.writeFile((0, path_1.join)(process.cwd(), fileName), bundlezip);
        }
    }
});
