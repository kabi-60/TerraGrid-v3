"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const iac_1 = __importDefault(require("../../endpoints/lib/iac"));
const api_timer_1 = __importDefault(require("../../api-timer"));
const option_1 = require("../../util_modules/option");
const error_1 = __importDefault(require("../../error"));
const throbber_1 = __importDefault(require("../../throbber"));
const logger_1 = require("../../util_modules/logger");
const util_1 = require("./util");
const env_1 = require("../../util_modules/env");
const ansi_colors_1 = require("ansi-colors");
const code_deck_1 = require("../../code-deck");
exports.default = () => __awaiter(void 0, void 0, void 0, function* () {
    const getSpinnerTxt = (0, util_1.getSpinnerTxt)(process.env.PARENT_COMMAND === 'codedeck' ? 'codedeck' : 'deploy');
    const idOpt = (0, option_1.getOptionValue)('id', false);
    const iacAPI = new iac_1.default();
    const allDeploys = yield iacAPI.allDeploys();
    if (allDeploys.length <= 0) {
        throw new error_1.default('No import projects available in server.');
    }
    const neededDeploys = allDeploys.filter((deploy) => deploy.id === idOpt || deploy.status === 'Scheduled');
    if (neededDeploys.length <= 0) {
        throw new error_1.default(idOpt
            ? 'No import projects with given id exists.'
            : 'No import projects currently scheduled.');
    }
    const deployDetails = neededDeploys[0];
    const throbber = throbber_1.default.getInstance();
    const spinner = deployDetails.id;
    throbber.add(spinner, {
        text: getSpinnerTxt(deployDetails)
    });
    const timerAPI = new api_timer_1.default(iacAPI.deployStatus.bind(iacAPI, deployDetails.id), 2000, 1);
    let lastStatus;
    timerAPI.on('data', (data) => __awaiter(void 0, void 0, void 0, function* () {
        switch (data.status) {
            case 'Scheduled':
            case 'Processing':
                throbber.update(spinner, {
                    text: getSpinnerTxt(data) +
                        (process.env.PARENT_COMMAND !== 'codedeck'
                            ? '\nPress CTRL + C to exit listening to the status'
                            : '')
                });
                break;
            case 'Error_Processing':
                throbber.fail(spinner, {
                    text: getSpinnerTxt(data, 'failed')
                });
                timerAPI.end();
                break;
            case 'Completed':
                throbber.succeed(spinner, {
                    text: getSpinnerTxt(data)
                });
                timerAPI.end(undefined, true);
                break;
            default:
                (0, logger_1.debug)('Unknown status received : ', data.status);
                timerAPI.end();
        }
        lastStatus = data.status;
    }));
    timerAPI.on('error', (e) => {
        (0, logger_1.debug)('Error encountered : ', e);
    });
    timerAPI.on('end', (_error, data) => {
        if (data === true && !(0, env_1.isPrimaryShell)() && process.send) {
            process.send('success');
        }
        throbber.stopAll();
    });
    process.env.PARENT_COMMAND === 'codedeck' &&
        process.on('exit', () => {
            if (lastStatus === 'Scheduled' || lastStatus === 'Processing') {
                (0, logger_1.info)();
                (0, logger_1.message)((0, ansi_colors_1.bold)('You can listen to the status of this CodeLib install by executing the below command'));
                process.env.GIT_URL &&
                    (0, logger_1.info)(`catalyst codelib:install --continue ${code_deck_1.CodeDeckToken.createToken(deployDetails.id, process.env.GIT_URL)}`);
            }
        });
    timerAPI.start();
    yield timerAPI.waitForEnd();
});
