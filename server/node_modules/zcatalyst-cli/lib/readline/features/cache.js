// 'use strict';

// var _ = require('lodash');
// var clc = require('cli-color');
// var readline = require('readline');

// var endpoints = require('../../endpoints');
// var logger = require('../../logger');
// var utils = require('../../utils');
// var readlineUtil = require('../../readLineUtils');

// var outputStream = process.stdout;
// var inputStream = process.stdin;

// module.exports = function(options) {
// 	var state = 0;
// 	var segment = '';
// 	const cacheAPI = endpoints(options).cache();
// 	return new Promise(function(resolve) {
// 		var prompt = clc.cyanBright('cache > ');

// 		function completer(line) {
// 			var completions = 'list use set get'.split(' ');
// 			var hits = completions.filter(function(c) {
// 				c.startsWith(line);
// 			});
// 			// show all completions if none found
// 			return [hits.length ? hits : completions, line];
// 		}
// 		// function completer(line) {
// 		//     var completions = ['use ', 'GET '];
// 		//     var lineArr = line.trim().split(' ');
// 		//     if (lineArr[(lineArr.length) - 1] !== '') {
// 		//         switch (lineArr[(lineArr.length) - 1]) {
// 		//             case 'use':
// 		//                 // completions[0] = completions[0] + 'segment ';
// 		//                 completions.pop();
// 		//                 completions.push('segment ');
// 		//                 break;
// 		//             default:
// 		//                 completions = [];
// 		//         }
// 		//         var hits = completions.filter((c) => line.startsWith(c) || line.endsWith(c));
// 		//         return [hits, line];
// 		//     }
// 		//     return [completions, line];
// 		// }
// 		var rl = readline.createInterface({
// 			input: inputStream,
// 			output: outputStream,
// 			prompt: prompt,
// 			completer: completer
// 		});

// 		rl.prompt();

// 		rl.on('line', function(line) {
// 			var originalLine = line.trim();
// 			var lineArr = readlineUtil.splitLineIntoArray(originalLine);
// 			return new Promise(function(resolve) {
// 				switch (true) {
// 					case /^exit/i.test(originalLine):
// 					case /\\q/i.test(originalLine):
// 						rl.close();
// 						break;
// 					case /^list/i.test(originalLine):
// 						return cacheAPI
// 							.listSegments(options.project)
// 							.then(function(data) {
// 								_.forEach(data, function(segment, index) {
// 									logger.info(
// 										index +
// 											1 +
// 											'. ' +
// 											clc.bold(segment.segment_name) +
// 											' ( ' +
// 											segment.id +
// 											' )'
// 									);
// 								});
// 								return resolve();
// 							})
// 							.catch(function(err) {
// 								logger.debug('There was an error processing the request.' + err);
// 								logger.info(clc.redBright("couldn't fetch segment details"));
// 								return resolve();
// 							});
// 					case /^use/i.test(originalLine):
// 						var segmentID = lineArr[lineArr.length - 1];
// 						if ((lineArr.length = 2 && /^[0-9]*$/gm.test(segmentID))) {
// 							segment = segmentID;
// 							state = 1;
// 							rl.setPrompt(clc.cyanBright('cache:' + segment + ' > '));
// 							return resolve();
// 						} else {
// 							readlineUtil.displayHelp('Segment ID not valid.');
// 							return resolve();
// 						}
// 					case /^get/i.test(line):
// 						if (state === 0) {
// 							utils.logWarning('Trying to get data from default segment', 'info');
// 						}
// 						if (lineArr.length === 2) {
// 							var cachekey = lineArr[lineArr.length - 1];
// 							return cacheAPI
// 								.get(options.project, segment, cachekey)
// 								.then(function(data) {
// 									data.cache_value
// 										? logger.info('"' + clc.greenBright(data.cache_value) + '"')
// 										: logger.info('(' + clc.redBright('nil') + ')');
// 									return resolve();
// 								})
// 								.catch(function(err) {
// 									logger.error(
// 										'There was an error processing the request.' + err
// 									);
// 									logger.info('(' + clc.redBright('error') + ')');
// 									return resolve();
// 								});
// 						} else {
// 							readlineUtil.displayHelp('Key Name not valid.');
// 							return resolve();
// 						}
// 					case /^set/i.test(line):
// 						if (state === 0) {
// 							utils.logWarning('Trying to put data to default segment', 'info');
// 						}
// 						if (lineArr.length === 3) {
// 							var data = {};
// 							data.key = lineArr[lineArr.length - 2];
// 							data.value = lineArr[lineArr.length - 1];
// 							return cacheAPI
// 								.put(options.project, segment, data)
// 								.then(function(data) {
// 									if (data) {
// 										logger.info(clc.greenBright('OK'));
// 									}
// 									return resolve();
// 								})
// 								.catch(function(err) {
// 									logger.debug(
// 										'There was an error processing the request.' + err
// 									);
// 									logger.info('(' + clc.redBright('error') + ')');
// 									return resolve();
// 								});
// 						} else {
// 							readlineUtil.displayHelp('Key or Value not valid.');
// 							return resolve();
// 						}
// 					case /^help/i.test(originalLine):
// 					case /^\\h/i.test(originalLine):
// 						utils.logBullet(
// 							'Available commands :\t ' + clc.bold('list, use, get, set, exit')
// 						);
// 						return resolve();
// 					default:
// 						logger.info(
// 							`We might have heard '${clc.bold(
// 								line.trim()
// 							)}'\n which is an unknown command!! Use '${clc.bold(
// 								'help'
// 							)}' for the list of commands you can use.`
// 						);
// 						return resolve();
// 				}
// 			}).then(function() {
// 				rl.prompt();
// 			});
// 		}).on('close', function() {
// 			logger.info('Have a great day!');
// 			return resolve();
// 		});
// 	});
// };
