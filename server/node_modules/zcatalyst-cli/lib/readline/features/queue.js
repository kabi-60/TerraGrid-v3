// 'use strict';

// var _ = require('lodash');
// var clc = require('cli-color');
// var readline = require('readline');

// var queueAPI = require('../../endpoints').queue;
// var logger = require('../../logger');
// var utils = require('../../utils');
// var readlineUtil = require('../../readLineUtils');

// var outputStream = process.stdout;
// var inputStream = process.stdin;

// var consumerTimeout;

// var listAllQueue = function(projectId, resolve) {
// 	return queueAPI
// 		.list(projectId)
// 		.then(function(data) {
// 			_.forEach(data, function(topic, index) {
// 				logger.info(
// 					index + 1 + '. ' + clc.bold(topic.queue_name) + ' ( ' + topic.id + ' )'
// 				);
// 			});
// 			return resolve(true);
// 		})
// 		.catch(function(err) {
// 			logger.debug('There was an error processing the request.' + err);
// 			logger.info(clc.redBright("couldn't fetch queue details"));
// 			return resolve(true);
// 		});
// };

// var produceToQueue = function(projectId, queueId, obj, resolve) {
// 	return queueAPI
// 		.produce(projectId, queueId, obj)
// 		.then(function() {
// 			// console.log(data);
// 			return resolve(false);
// 		})
// 		.catch(function(err) {
// 			logger.debug('There was an error processing the request.' + err);
// 			logger.info(clc.redBright("couldn't produce to queue. Please check the queue id."));
// 			return resolve(false);
// 		});
// };

// var startConsumerTimeout = function(projectId, queueId, delayInMillis) {
// 	consumerTimeout = setInterval(function() {
// 		return queueAPI
// 			.consume(projectId, queueId)
// 			.then(function(data) {
// 				if (data) {
// 					console.log(data[0].value);
// 				}
// 			})
// 			.catch(function(err) {
// 				logger.debug('There was an error processing the request.' + err);
// 				// clearInterval(consumerTimeout);
// 			});
// 	}, delayInMillis);
// };

// module.exports = function(options) {
// 	var state = 0;
// 	var queue = '';
// 	var consumerAlive = false;
// 	var producerAlive = false;

// 	return new Promise(function(resolve) {
// 		var prompt = clc.cyanBright('queue > ');
// 		var prevPrompt = prompt;

// 		function completer(line) {
// 			var completions = 'list use start-producer start-consumer'.split(' ');
// 			var hits = completions.filter(function(c) {
// 				c.startsWith(line);
// 			});
// 			// show all completions if none found
// 			return [hits.length ? hits : completions, line];
// 		}
// 		var rl = readline.createInterface({
// 			input: inputStream,
// 			output: outputStream,
// 			prompt: prompt,
// 			completer: completer
// 		});

// 		rl.on('line', function(line) {
// 			var originalLine = line.trim();
// 			var lineArr = readlineUtil.splitLineIntoArray(originalLine);
// 			return new Promise(function(resolve) {
// 				if (producerAlive) {
// 					if (originalLine === '') {
// 						readlineUtil.displayHelp('cannot produce a empty msg to queue.');
// 						return resolve(true);
// 					}
// 					var obj = {};
// 					obj.value = line;
// 					return produceToQueue(options.project, queue, obj, resolve);
// 				}
// 				if (consumerAlive) {
// 					return resolve(false);
// 				}
// 				switch (true) {
// 					case /^exit/i.test(originalLine):
// 					case /\\q/i.test(originalLine):
// 						rl.close();
// 						break;
// 					case /^list/i.test(originalLine):
// 						if (lineArr.length === 1) {
// 							return listAllQueue(options.project, resolve);
// 						} else {
// 							readlineUtil.displayHelp('use of additional params not permitted.');
// 							return resolve(true);
// 						}
// 					case /^use/i.test(originalLine):
// 						var queueID = lineArr[lineArr.length - 1];
// 						if (lineArr.length === 2 && /^[0-9]*$/gm.test(queueID)) {
// 							queue = queueID;
// 							state = 1;
// 							prevPrompt = prompt;
// 							prompt = clc.cyanBright('queue:' + queue + ' > ');
// 							rl.setPrompt(prompt);
// 							return resolve(true);
// 						} else {
// 							readlineUtil.displayHelp('Queue ID not valid.');
// 							return resolve(true);
// 						}
// 					case /^start-consumer/i.test(line):
// 						if (state === 0) {
// 							utils.logWarning(
// 								'You must select a queue first. Try ' + clc.bold('use <queueId>'),
// 								'info'
// 							);
// 							return resolve(true);
// 						} else if (lineArr.length === 1) {
// 							consumerAlive = true;
// 							prevPrompt = prompt;
// 							prompt = '';
// 							rl.setPrompt(prompt);
// 							startConsumerTimeout(options.project, queue, 5000);
// 							return resolve(false);
// 						} else {
// 							readlineUtil.displayHelp('use of additional params not permitted.');
// 							return resolve(true);
// 						}
// 					case /^start-producer/i.test(line):
// 						if (state === 0) {
// 							utils.logWarning(
// 								'You must select a queue first. Try ' + clc.bold('use <queueId>'),
// 								'info'
// 							);
// 							return resolve(true);
// 						} else if (lineArr.length === 1) {
// 							producerAlive = true;
// 							prevPrompt = prompt;
// 							prompt = '';
// 							rl.setPrompt(prompt);
// 							return resolve(false);
// 						} else {
// 							readlineUtil.displayHelp('use of additional params not permitted.');
// 							return resolve(true);
// 						}
// 					case /^help/i.test(originalLine):
// 					case /^\\h/i.test(originalLine):
// 						utils.logBullet(
// 							'Available commands :\t ' +
// 								clc.bold('list, use, start-producer, start-consumer, exit')
// 						);
// 						return resolve(true);
// 					default:
// 						logger.info(
// 							`We might have heard '${clc.bold(
// 								line.trim()
// 							)}'\n which is an unknown command!! Use '${clc.bold(
// 								'help'
// 							)}' for the list of commands you can use.`
// 						);
// 						return resolve(true);
// 				}
// 			}).then(function(showPrompt) {
// 				if (showPrompt) {
// 					rl.prompt();
// 				}
// 			});
// 		}).on('close', function() {
// 			logger.info('Have a great day!');
// 			return resolve();
// 		});

// 		rl.on('SIGINT', function() {
// 			if (!producerAlive && !consumerAlive) {
// 				rl.close();
// 			} else {
// 				producerAlive = producerAlive ? !producerAlive : producerAlive;
// 				consumerAlive = consumerAlive ? !consumerAlive : consumerAlive;
// 				if (consumerTimeout) {
// 					clearInterval(consumerTimeout);
// 				}
// 				prompt = prevPrompt;
// 				rl.setPrompt(prompt);
// 				rl.prompt();
// 			}
// 		});
// 		rl.prompt();
// 	});
// };
