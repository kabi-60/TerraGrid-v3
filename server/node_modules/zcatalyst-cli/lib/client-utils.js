'use strict';
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.clientUtils = void 0;
const ansi_colors_1 = require("ansi-colors");
const path_1 = require("path");
const archiver_1 = __importDefault(require("./archiver"));
const error_1 = __importDefault(require("./error"));
const execute_script_1 = __importDefault(require("./execute-script"));
const plugin_loader_1 = __importDefault(require("./plugin-loader"));
const runtime_store_1 = __importDefault(require("./runtime-store"));
const config_1 = require("./util_modules/config");
const constants_1 = require("./util_modules/constants");
const fs_1 = require("./util_modules/fs");
const js_1 = require("./util_modules/js");
const logger_1 = require("./util_modules/logger");
const option_1 = require("./util_modules/option");
const project_1 = require("./util_modules/project");
const stream_1 = require("stream");
exports.clientUtils = {
    validate: (source) => __awaiter(void 0, void 0, void 0, function* () {
        const sourceDir = source || (0, project_1.resolveProjectPath)(config_1.clientConfig.source());
        const packageJsonFile = (0, path_1.join)(sourceDir, constants_1.FILENAME.client.package_json);
        const sourceDirExists = yield fs_1.ASYNC.dirExists(sourceDir);
        if (!sourceDirExists) {
            throw new error_1.default('source directory does not exist', {
                exit: 1,
                errorId: 'CLIENT-UTILS-1',
                arg: [ansi_colors_1.italic.red(sourceDir), (0, ansi_colors_1.bold)(constants_1.FILENAME.config), (0, ansi_colors_1.bold)('catalyst client:setup')]
            });
        }
        const packageJson = yield fs_1.ASYNC.readJSONFile(packageJsonFile, {
            checkpath: true
        }).catch((e) => {
            throw new error_1.default(constants_1.FILENAME.client.package_json + ' file cannot be parsed.', {
                exit: 1,
                original: e,
                errorId: 'CLIENT-UTILS-2',
                arg: [(0, ansi_colors_1.bold)(packageJsonFile), (0, ansi_colors_1.bold)('Error: ') + ansi_colors_1.italic.red(e.message)]
            });
        });
        if (packageJson === undefined) {
            throw new error_1.default(constants_1.FILENAME.client.package_json + ' file was not found.', {
                exit: 1,
                errorId: 'CLIENT-UTILS-3',
                arg: [(0, ansi_colors_1.bold)(packageJsonFile), (0, ansi_colors_1.bold)(constants_1.FILENAME.client.package_json)]
            });
        }
        const name = js_1.JS.get(packageJson, 'name', null);
        const homepage = js_1.JS.get(packageJson, 'homepage', 'index.html');
        const notFoundPagePath = js_1.JS.get(packageJson, '404', '404.html');
        if (homepage === notFoundPagePath) {
            throw new error_1.default('404 page and homepage cannot be the same', {
                exit: 1,
                errorId: 'CLIENT-UTILS-7',
                arg: [(0, ansi_colors_1.bold)('404'), (0, ansi_colors_1.bold)('HOME'), ansi_colors_1.italic.red(homepage)]
            });
        }
        const notFoundPage = notFoundPagePath && (yield fs_1.ASYNC.fileExists((0, path_1.resolve)(sourceDir, notFoundPagePath)))
            ? (0, path_1.resolve)(sourceDir, notFoundPagePath)
            : (yield fs_1.ASYNC.fileExists((0, path_1.join)(sourceDir, constants_1.FILENAME.client.notFoundPage))) &&
                (0, path_1.join)(sourceDir, constants_1.FILENAME.client.notFoundPage);
        const loginRedirect = runtime_store_1.default.get('context.client.login_redirect', packageJson.login_redirect);
        if (js_1.JS.isNull(name)) {
            throw new error_1.default(constants_1.FILENAME.client.package_json + ' file is corrupted.', {
                exit: 1,
                errorId: 'CLIENT-UTILS-4',
                arg: [(0, ansi_colors_1.bold)(packageJsonFile), (0, ansi_colors_1.bold)('name')]
            });
        }
        runtime_store_1.default.set('context.client.name', name);
        runtime_store_1.default.set('context.client.homepage', homepage);
        runtime_store_1.default.set('context.client.source', sourceDir);
        runtime_store_1.default.set('context.client.login_redirect', loginRedirect || homepage);
        runtime_store_1.default.set('context.client.package_json', packageJsonFile);
        runtime_store_1.default.set('context.client.notFoundPage', notFoundPage);
        const validatePlugin = yield (0, plugin_loader_1.default)('client', 'validate').catch((err) => (0, logger_1.debug)(err));
        if (typeof validatePlugin !== 'function') {
            runtime_store_1.default.set('context.client.valid', true);
            return packageJson;
        }
        const logStreamPlugin = yield (0, plugin_loader_1.default)('client', 'logs').catch((err) => (0, logger_1.debug)(err));
        let stream;
        const streamLogFn = (chunk) => (0, logger_1.log)('info', chunk.toString(), true);
        if (typeof logStreamPlugin === 'function') {
            stream = yield logStreamPlugin();
            stream instanceof stream_1.Stream && stream.on('data', streamLogFn);
        }
        try {
            yield validatePlugin((0, option_1.getCurrentCommand)(), sourceDir, runtime_store_1.default, packageJson);
        }
        catch (e) {
            const err = error_1.default.getErrorInstance(e, {
                skipHelp: false
            });
            err.errorId = 'CLIENT-UTILS-5';
            err.arg = [
                'validating',
                (0, ansi_colors_1.bold)(config_1.clientConfig.plugin('validate') || 'unknown'),
                (0, ansi_colors_1.bold)('Error: ') + ansi_colors_1.italic.red(err.message)
            ];
            throw err;
        }
        finally {
            stream instanceof stream_1.Stream && stream.removeListener('data', streamLogFn);
        }
        runtime_store_1.default.set('context.client.valid', true);
        return packageJson;
    }),
    executeHook: ({ prefix, command }) => {
        if ((0, option_1.getOptionValue)('ignoreScripts', false)) {
            (0, logger_1.debug)(`skipping ${prefix + command} hook`);
            return;
        }
        const exeCommand = config_1.clientConfig.script(prefix + command, null);
        if (exeCommand === null) {
            return;
        }
        (0, execute_script_1.default)('client:' + prefix + command);
    },
    pack: () => __awaiter(void 0, void 0, void 0, function* () {
        let source = (0, project_1.resolveProjectPath)(config_1.clientConfig.source());
        const buildPlugin = yield (0, plugin_loader_1.default)('client', 'build').catch((err) => (0, logger_1.debug)(err));
        if (typeof buildPlugin === 'function') {
            process.env.X_CATALYST_WEBAPP_PATH = source;
            const logStreamPlugin = yield (0, plugin_loader_1.default)('client', 'logs').catch((err) => (0, logger_1.debug)(err));
            let stream;
            const streamLogFn = (chunk) => (0, logger_1.log)('info', chunk.toString(), true);
            if (typeof logStreamPlugin === 'function') {
                stream = yield logStreamPlugin();
                stream instanceof stream_1.Stream && stream.on('data', streamLogFn);
            }
            try {
                (0, logger_1.message)(`Plugin : "${runtime_store_1.default.get(`context.client.plugins.build`)}" is used for client deploy`);
                (0, logger_1.message)('Building Application...');
                const outputDir = yield buildPlugin(source, runtime_store_1.default);
                if (typeof outputDir !== 'string') {
                    throw new Error('unexpected return value from build plugin, ' + source);
                }
                source = outputDir;
            }
            catch (e) {
                const err = error_1.default.getErrorInstance(e, {
                    skipHelp: false
                });
                err.errorId = 'CLIENT-UTILS-5';
                err.arg = [
                    'building',
                    (0, ansi_colors_1.bold)(config_1.clientConfig.plugin('build') || 'unknown'),
                    (0, ansi_colors_1.bold)('Error: ') + ansi_colors_1.italic.red(err.message)
                ];
                throw err;
            }
            finally {
                stream instanceof stream_1.Stream &&
                    stream.removeListener('data', streamLogFn);
            }
        }
        const exclude = config_1.clientConfig.ignore(source);
        const files = yield fs_1.ASYNC.walk(source, { filter: { exclude, excludeDir: true } });
        const zip = new archiver_1.default();
        files.forEach((file) => {
            zip.add(file.path.replace(source + path_1.sep, ''), file.stats.isSymbolicLink()
                ? fs_1.SYNC.readSymLink(file.path)
                : fs_1.SYNC.getReadStream(file.path), {
                mode: file.stats.mode
            });
        });
        const zipFinalizer = yield zip.finalize();
        return zipFinalizer.fsStream();
    }),
    deleteClientLocal: (path) => __awaiter(void 0, void 0, void 0, function* () {
        const isDirectory = yield fs_1.ASYNC.dirExists(path);
        const conf = runtime_store_1.default.get('config');
        if (isDirectory) {
            yield fs_1.ASYNC.deleteDir(path);
        }
        conf.unset('client');
        yield conf.save();
    })
};
