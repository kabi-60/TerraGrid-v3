"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const choices_1 = __importDefault(require("inquirer/lib/objects/choices"));
const inquirer_autocomplete_prompt_1 = __importDefault(require("inquirer-autocomplete-prompt"));
const fuzzy_1 = __importDefault(require("fuzzy"));
const fs_1 = require("../../util_modules/fs");
const ansi_colors_1 = require("ansi-colors");
function getPaths(rootPath, pattern, exclude, defaultItem) {
    return __awaiter(this, void 0, void 0, function* () {
        const nodeList = yield fs_1.ASYNC.walk(rootPath, {
            filter: { exclude, excludeDir: false },
            includeDirPaths: true
        });
        const filteredNodes = fuzzy_1.default
            .filter(pattern || '', nodeList, { extract: (node) => node.path })
            .map((e) => e.string);
        if (!pattern && defaultItem) {
            filteredNodes.unshift(defaultItem);
        }
        return filteredNodes;
    });
}
class InquirerFilePath extends inquirer_autocomplete_prompt_1.default {
    constructor(question, rl, answers) {
        const { rootPath = '.', exclude = [] } = question;
        const questionBase = Object.assign({
            emptyText: 'No valid file inside current directory!. Try giving the entire path and press ' +
                (0, ansi_colors_1.cyan)('<return> ') +
                'key'
        }, question, {
            source: (_, pattern) => getPaths(rootPath, pattern, exclude, question.default)
        });
        super(questionBase, rl, answers);
    }
    search(searchTerm) {
        const _super = Object.create(null, {
            search: { get: () => super.search }
        });
        return __awaiter(this, void 0, void 0, function* () {
            yield _super.search.call(this, searchTerm);
            this.currentChoices.getChoice = (choiceIndex) => {
                const choice = choices_1.default.prototype.getChoice.call(this.currentChoices, choiceIndex);
                return {
                    value: choice === null || choice === void 0 ? void 0 : choice.value,
                    name: choice === null || choice === void 0 ? void 0 : choice.name,
                    short: choice === null || choice === void 0 ? void 0 : choice.short
                };
            };
        });
    }
    onSubmitAfterValidation(line) {
        return __awaiter(this, void 0, void 0, function* () {
            const choice = this.currentChoices.getChoice(this.selected);
            const value = (choice === null || choice === void 0 ? void 0 : choice.value) || line;
            this.answerName = (choice === null || choice === void 0 ? void 0 : choice.name) || line;
            this.shortAnswer = (choice === null || choice === void 0 ? void 0 : choice.short) || line;
            this.answer = this.opt.filter ? this.opt.filter(value, this.answers) : value;
            choice.value = this.answer;
            this.status = 'answered';
            this.render(undefined);
            this.screen.done();
            if (this.done) {
                this.done(choice.value);
            }
        });
    }
    checkValidationResult(validationResult, lineOrRl) {
        if (validationResult !== true) {
            this.render(validationResult || 'try giving valid complete path..');
        }
        else {
            this.onSubmitAfterValidation(lineOrRl);
        }
    }
    onSubmit(line) {
        return __awaiter(this, void 0, void 0, function* () {
            const lineOrRl = line || this.rl.line;
            if (typeof this.opt.validate !== 'function') {
                return this.onSubmitAfterValidation(lineOrRl);
            }
            const choice = this.currentChoices.getChoice(this.selected);
            choice.value = choice.value ? choice.value : lineOrRl;
            const validationResult = yield this.opt.validate(choice, this.answers);
            this.checkValidationResult(validationResult, lineOrRl);
        });
    }
}
exports.default = InquirerFilePath;
