'use strict';
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.copyModDirPerm = exports.updateFnConfig = exports.getSDK = exports.deleteFunctionLocal = exports.resolveAllFnPorts = exports.findAndReplaceConfigProps = exports.generateUrlForTarget = exports.pack = exports.executeHook = exports.refineTargets = exports.validate = void 0;
const ansi_colors_1 = require("ansi-colors");
const path_1 = require("path");
const archiver_1 = __importDefault(require("../../archiver"));
const endpoints_1 = require("../../endpoints");
const catalyst_details_1 = __importDefault(require("../../endpoints/lib/catalyst-details"));
const error_1 = __importDefault(require("../../error"));
const execute_script_1 = __importDefault(require("../../execute-script"));
const plugin_loader_1 = __importDefault(require("../../plugin-loader"));
const port_resolver_1 = __importDefault(require("../../port-resolver"));
const prompt_1 = __importDefault(require("../../prompt"));
const runtime_store_1 = __importDefault(require("../../runtime-store"));
const config_1 = require("../../util_modules/config");
const constants_1 = require("../../util_modules/constants");
const runtime_1 = __importDefault(require("../../util_modules/constants/lib/runtime"));
const fs_1 = require("../../util_modules/fs");
const js_1 = require("../../util_modules/js");
const logger_1 = require("../../util_modules/logger");
const option_1 = require("../../util_modules/option");
const project_1 = require("../../util_modules/project");
const fs_2 = require("fs");
const os_1 = require("os");
const pip_install_1 = require("../../init/dependencies/python/pip-install");
function validate() {
    return __awaiter(this, void 0, void 0, function* () {
        const sourceDir = (0, project_1.resolveProjectPath)(config_1.functionsConfig.source());
        const fnTargets = config_1.functionsConfig.targets();
        if (fnTargets === undefined || fnTargets.length === 0) {
            throw new error_1.default('targets was found to be empty', {
                exit: 1,
                errorId: 'COMMON-1',
                arg: [(0, ansi_colors_1.bold)('targets'), (0, ansi_colors_1.bold)(constants_1.FILENAME.config)]
            });
        }
        const sourceExists = yield fs_1.ASYNC.dirExists(sourceDir);
        if (!sourceExists) {
            throw new error_1.default(sourceDir + ' directory was not found', {
                exit: 1,
                errorId: 'COMMON-2',
                arg: [(0, ansi_colors_1.bold)((0, path_1.basename)(sourceDir)), (0, ansi_colors_1.bold)(constants_1.FILENAME.config)]
            });
        }
        const only = (0, option_1.getOptionValue)('only');
        let fnFilterGroups = [];
        if (only !== undefined) {
            fnFilterGroups = only
                .split(',')
                .filter((filter) => {
                const opts = filter.split(':');
                return opts[0] === 'functions' && opts[1];
            })
                .map((filter) => filter.split(':')[1]);
        }
        else {
            const except = (0, option_1.getOptionValue)('except', null);
            if (except !== null) {
                const invalidFn = [];
                const exceptFnGroup = js_1.JS.chain(except.split(','))
                    .filter((filter) => {
                    const opts = filter.split(':');
                    if (opts[0] === 'functions' && opts[1]) {
                        if (fnTargets.includes(opts[1])) {
                            return true;
                        }
                        invalidFn.push(opts[1]);
                    }
                    return false;
                })
                    .map((filter) => filter.split(':')[1])
                    .value();
                if (invalidFn.length > 0) {
                    (0, logger_1.message)(`The filters ${(0, ansi_colors_1.bold)(invalidFn.join(', '))} provided with --except option does not match with any functions in ${constants_1.FILENAME.config}, hence ignored.`);
                }
                fnFilterGroups = fnTargets.filter((fnTarget) => !exceptFnGroup.includes(fnTarget));
                if (fnFilterGroups.length === fnTargets.length && invalidFn.length > 0) {
                    (0, logger_1.message)(`No match found for ${(0, ansi_colors_1.bold)('except')} option in functions. Hence, ignoring ${(0, ansi_colors_1.bold)('except')} option for functions.`);
                }
                if (fnFilterGroups.length === 0 && exceptFnGroup.length > 0) {
                    return fnFilterGroups;
                }
            }
        }
        if (fnFilterGroups.length > 0 && only !== null) {
            const unmatchedFilters = fnFilterGroups.filter((filterGroup) => {
                return !js_1.JS.some(js_1.JS.map(fnTargets, (existingGrpName) => {
                    return js_1.JS.isEqual(filterGroup, existingGrpName.slice(0, filterGroup.length));
                }));
            });
            if (unmatchedFilters.length > 0) {
                const formattedTargets = fnTargets.map((fn) => '* ' + fn).join('\n');
                throw new error_1.default('The filters ' +
                    (0, ansi_colors_1.bold)(unmatchedFilters.join(', ')) +
                    ' provided with --only option does not match with any functions in ' +
                    constants_1.FILENAME.config, {
                    exit: 1,
                    errorId: 'COMMON-3',
                    arg: [
                        (0, ansi_colors_1.bold)(unmatchedFilters.join(', ')),
                        (0, ansi_colors_1.bold)('--only'),
                        (0, ansi_colors_1.bold)(constants_1.FILENAME.config),
                        (0, ansi_colors_1.bold)(formattedTargets)
                    ]
                });
            }
        }
        const filteredFns = fnFilterGroups.length > 0 ? js_1.JS.intersection(fnTargets, fnFilterGroups) : fnTargets;
        const filteredFnsPath = filteredFns.map((target) => (0, path_1.join)(sourceDir, target));
        runtime_store_1.default.set('context.functions.targets', filteredFnsPath);
        return filteredFnsPath;
    });
}
exports.validate = validate;
function refineTargets(rawTargets, mapRemoteFn = true) {
    return __awaiter(this, void 0, void 0, function* () {
        let remoteFnMap = {};
        let runtimeDetails = runtime_store_1.default.get('context.catalyst.runtime', { runtimes: [] });
        if (mapRemoteFn) {
            const fnAPI = yield (0, endpoints_1.functionsAPI)();
            let allRemoteFns = [];
            [allRemoteFns, runtimeDetails] = yield Promise.all([
                fnAPI.getAllFunctions(),
                runtimeDetails
                    ? Promise.resolve(runtimeDetails)
                    : new catalyst_details_1.default().getDetails('runtime')
            ]);
            runtime_store_1.default.set('context.catalyst.runtime', runtimeDetails);
            if (!Array.isArray(allRemoteFns) || allRemoteFns.length === 0) {
                allRemoteFns = [];
            }
            remoteFnMap = allRemoteFns.reduce((accumulator, fn) => {
                accumulator[fn.name] = fn;
                return accumulator;
            }, remoteFnMap);
        }
        return Promise.all(rawTargets.map((fnPath) => __awaiter(this, void 0, void 0, function* () {
            var _a;
            fnPath = (0, project_1.resolveProjectPath)(fnPath);
            const catalystJsonPth = (0, path_1.join)(fnPath, constants_1.FILENAME.catalyst_config);
            const catalystJson = yield fs_1.ASYNC.readJSONFile(catalystJsonPth, {
                checkpath: true,
                throws: false
            });
            if (!catalystJson) {
                return {
                    name: (0, path_1.basename)(fnPath),
                    source: fnPath,
                    valid: false,
                    failure_reason: 'there is no valid ' + constants_1.FILENAME.catalyst_config + ' file present'
                };
            }
            const validatePlugin = yield (0, plugin_loader_1.default)('functions', 'validate', fnPath).catch((err) => (0, logger_1.debug)(err));
            if (typeof validatePlugin === 'function') {
                try {
                    yield validatePlugin((0, option_1.getCurrentCommand)(), fnPath, runtime_store_1.default, catalystJson);
                }
                catch (e) {
                    throw new error_1.default(e.message, {
                        exit: 1,
                        errorId: 'COMMON-4',
                        original: e,
                        arg: ['validating', e.toString()]
                    });
                }
            }
            const fnName = js_1.JS.get(catalystJson, 'deployment.name');
            const userStack = js_1.JS.get(catalystJson, 'deployment.stack');
            const fnType = constants_1.REFERENCE.functions.type[js_1.JS.get(catalystJson, 'deployment.type')];
            if (!userStack ||
                (runtimeDetails.runtimes.length > 0 && !runtimeDetails.runtimes.includes(userStack))) {
                return {
                    name: (0, path_1.basename)(fnPath),
                    source: fnPath,
                    valid: false,
                    type: fnType,
                    failure_reason: 'deployment.stack is unknown in ' + constants_1.FILENAME.catalyst_config + ' file.'
                };
            }
            const eol = runtimeDetails.eol_runtimes && runtimeDetails.eol_runtimes[userStack];
            switch (eol) {
                case 1:
                case 2:
                    if (eol === 2 && remoteFnMap[fnName] === undefined) {
                        return {
                            name: fnName,
                            source: fnPath,
                            valid: false,
                            type: fnType,
                            failure_reason: `Stack ${userStack} is no longer supported for creation. Kindly change the stack in ${constants_1.FILENAME.catalyst_config} and try again.`
                        };
                    }
                    (0, logger_1.labeled)(`functions(${fnName}) `, `Stack ${userStack} has reached EOL. Kindly update it as soon as possible.`).MESSAGE();
                    break;
                case 3:
                    return {
                        name: fnName,
                        source: fnPath,
                        valid: false,
                        type: fnType,
                        failure_reason: `Stack ${userStack} is no longer support. Kindly change the stack in ${constants_1.FILENAME.catalyst_config} and try again.`
                    };
                default:
                    (0, logger_1.debug)(`unknown eol ${eol} hence skipping check`);
                    break;
            }
            let deploymentType = js_1.JS.get(catalystJson, 'deployment.type');
            if (deploymentType && deploymentType === constants_1.REMOTE_REF.functions.type[constants_1.FN_TYPE.applogic]) {
                deploymentType = constants_1.REMOTE_REF.functions.type[constants_1.FN_TYPE.advanced];
                js_1.JS.set(catalystJson, 'deployment.type', deploymentType);
                const catalystJsonString = JSON.stringify(catalystJson, null, 2) + '\n';
                yield fs_1.ASYNC.writeFile(catalystJsonPth, catalystJsonString, 'utf8');
            }
            const fnMemory = js_1.JS.get(catalystJson, 'deployment.memory', js_1.JS.get(remoteFnMap[fnName], 'configuration.memory'));
            const fnTarget = {
                name: fnName,
                stack: userStack,
                type: fnType,
                index: js_1.JS.get(catalystJson, 'execution.main'),
                source: fnPath,
                valid: true,
                integ_config: js_1.JS.get(catalystJson, 'deployment.integration_config'),
                env_var: refineEnvVariables(js_1.JS.get(catalystJson, 'deployment.env_variables')),
                memory: fnMemory
            };
            if (mapRemoteFn && remoteFnMap[fnTarget.name] !== undefined) {
                fnTarget.id = (_a = remoteFnMap[fnTarget.name]) === null || _a === void 0 ? void 0 : _a.id;
            }
            return fnTarget;
        })));
    });
}
exports.refineTargets = refineTargets;
function refineEnvVariables(vars) {
    return !vars
        ? undefined
        : Object.entries(vars).reduce((envObj, curEntry) => {
            envObj[curEntry[0]] =
                typeof curEntry[1] === 'object' ? JSON.stringify(curEntry[1]) : curEntry[1];
            return envObj;
        }, {});
}
function executeHook({ prefix, command }) {
    if ((0, option_1.getOptionValue)('ignoreScripts', false)) {
        (0, logger_1.debug)(`skipping ${prefix + command} hook`);
        return;
    }
    const exeCommand = config_1.functionsConfig.script(prefix + command, null);
    if (exeCommand === null) {
        return;
    }
    (0, execute_script_1.default)('functions:' + prefix + command);
}
exports.executeHook = executeHook;
function pack(target) {
    var _a, _b;
    return __awaiter(this, void 0, void 0, function* () {
        try {
            let source = target.source;
            const buildPlugin = yield (0, plugin_loader_1.default)('functions', 'build', source).catch((err) => (0, logger_1.debug)(err));
            if (typeof buildPlugin === 'function') {
                try {
                    (0, logger_1.message)(`Plugin : "${runtime_store_1.default.get(`context.functions.plugins.build.${source}`)}" is used for functions deploy`);
                    const outputDir = yield buildPlugin(source, runtime_store_1.default);
                    if (typeof outputDir !== 'string') {
                        throw new Error('unexpected return value from build plugin, ' + source);
                    }
                    source = outputDir;
                }
                catch (e) {
                    throw new error_1.default(e.message, {
                        exit: 1,
                        errorId: 'COMMON-4',
                        original: e,
                        arg: ['building', e.toString()]
                    });
                }
            }
            const zip = new archiver_1.default(target.name);
            if ((_a = target.stack) === null || _a === void 0 ? void 0 : _a.startsWith(runtime_1.default.language.java.value)) {
                const outputFolder = (0, path_1.join)(source, constants_1.FOLDERNAME.output);
                const outputFiles = yield fs_1.ASYNC.walk(outputFolder);
                outputFiles.forEach((file) => {
                    zip.add(file.path.replace(outputFolder + path_1.sep, ''), file.stats.isSymbolicLink()
                        ? fs_1.SYNC.readSymLink(file.path)
                        : fs_1.SYNC.getReadStream(file.path), {
                        mode: file.stats.mode
                    });
                });
            }
            else {
                const exclude = config_1.functionsConfig.ignore(source);
                const files = yield fs_1.ASYNC.walk(source, { filter: { exclude, excludeDir: true } });
                files.forEach((file) => {
                    zip.add(file.path.replace(source + path_1.sep, ''), file.stats.isSymbolicLink()
                        ? fs_1.SYNC.readSymLink(file.path)
                        : fs_1.SYNC.getReadStream(file.path), {
                        mode: file.stats.mode
                    });
                });
            }
            if ((_b = target.stack) === null || _b === void 0 ? void 0 : _b.startsWith(runtime_1.default.language.python.value)) {
                const reqFile = (0, path_1.join)(target.source, constants_1.FILENAME.functions.python_requirements);
                const requirementsExists = yield fs_1.ASYNC.readFile(reqFile);
                if (requirementsExists) {
                    const tmpDir = (0, path_1.join)((0, os_1.tmpdir)(), '.catalyst', 'python', target.name + Date.now().toString());
                    yield fs_1.ASYNC.ensureDir(tmpDir);
                    yield fs_1.ASYNC.emptyDir(tmpDir);
                    yield (0, pip_install_1.installRequirements)(reqFile, tmpDir, target.stack.replace('python_', ''), true);
                    const files = yield fs_1.ASYNC.walk(tmpDir);
                    files.forEach((file) => {
                        zip.add(file.path.replace(tmpDir + path_1.sep, ''), file.stats.isSymbolicLink()
                            ? fs_1.SYNC.readSymLink(file.path)
                            : fs_1.SYNC.getReadStream(file.path), {
                            mode: file.stats.mode
                        });
                    });
                }
            }
            const finalizer = yield zip.finalize();
            const zipFsStream = yield finalizer.fsStream();
            target.valid = true;
            target.zip_stream = zipFsStream;
        }
        catch (err) {
            target.valid = false;
            target.failure_reason = err.message;
        }
    });
}
exports.pack = pack;
function generateUrlForTarget(target) {
    const urlDefault = 'https://' + (0, project_1.getDomainPrefix)() + '.' + constants_1.ORIGIN.app.replace('https://', '');
    switch (target.type) {
        case constants_1.FN_TYPE.basic:
        case constants_1.FN_TYPE.browserLogic:
            target.url = `${urlDefault}/server/${target.name}/execute`;
            if (target.id !== undefined) {
                target.url_with_id = `${urlDefault}/server/${target.id}/execute`;
            }
            break;
        case constants_1.FN_TYPE.advanced:
            target.url = `${urlDefault}/server/${target.name}/`;
            break;
        default:
            break;
    }
    return target.url;
}
exports.generateUrlForTarget = generateUrlForTarget;
function findAndReplaceConfigProps(dir, { stack, type, integ_config }) {
    return __awaiter(this, void 0, void 0, function* () {
        return fs_1.ASYNC.findAndReplace(dir)([
            constants_1.PLACEHOLDER.catalyst_config.stack,
            constants_1.PLACEHOLDER.catalyst_config.type,
            constants_1.PLACEHOLDER.catalyst_config.integ_config
        ], [stack, constants_1.REMOTE_REF.functions.type[type], integ_config]);
    });
}
exports.findAndReplaceConfigProps = findAndReplaceConfigProps;
function resolveAllFnServePort(targets) {
    return __awaiter(this, void 0, void 0, function* () {
        let isBioHttp = false;
        let isBioDebug = false;
        const debugOpts = runtime_store_1.default.get('context.port.debug', false);
        yield Promise.all(targets.map((target) => __awaiter(this, void 0, void 0, function* () {
            var _a;
            if (!target.valid) {
                return;
            }
            let curTargetType = target.type;
            if (curTargetType === constants_1.FN_TYPE.basic &&
                ((_a = target.stack) === null || _a === void 0 ? void 0 : _a.startsWith(runtime_1.default.language.python.value))) {
                curTargetType = constants_1.FN_TYPE.advanced;
            }
            if (debugOpts) {
                if (!isBioDebug && curTargetType === constants_1.FN_TYPE.basic) {
                    isBioDebug = true;
                    const debugPort = yield port_resolver_1.default.getPort(curTargetType, 'debug', {
                        name: target.name,
                        duplicateCheck: true,
                        searchSpan: 0
                    });
                    runtime_store_1.default.set('context.port.debug.' + curTargetType, debugPort);
                }
                else if (typeof debugOpts[curTargetType] === 'object' &&
                    target.name in debugOpts[curTargetType]) {
                    const debugPort = yield port_resolver_1.default.getPort(curTargetType, 'debug', {
                        name: target.name,
                        duplicateCheck: false,
                        searchSpan: 0
                    });
                    runtime_store_1.default.set('context.port.debug.functions.' + target.name, debugPort);
                }
            }
            if (curTargetType === constants_1.FN_TYPE.basic && isBioHttp) {
                return;
            }
            const httpPort = yield port_resolver_1.default.getPort(curTargetType, 'http', {
                name: target.name,
                duplicateCheck: curTargetType === constants_1.FN_TYPE.advanced || curTargetType === constants_1.FN_TYPE.browserLogic
            });
            if (curTargetType === constants_1.FN_TYPE.basic) {
                runtime_store_1.default.set('context.port.http.' + constants_1.FN_TYPE.basic, httpPort);
                isBioHttp = true;
            }
            else {
                runtime_store_1.default.set('context.port.http.functions.' + target.name, httpPort);
            }
        })));
        if (debugOpts && 'basicio' in debugOpts) {
            const bioDebugPort = yield port_resolver_1.default.getPort('bio', 'debug', {
                duplicateCheck: false,
                searchSpan: 0
            });
            runtime_store_1.default.set('context.port.debug.basicio', bioDebugPort);
        }
    });
}
function resolveAllFnPorts(targets) {
    return __awaiter(this, void 0, void 0, function* () {
        switch ((0, option_1.getCurrentCommand)()) {
            case 'serve': {
                if (!targets) {
                    throw new error_1.default('Invalid targets', { exit: 2 });
                }
                return resolveAllFnServePort(targets);
            }
            case 'functions:shell': {
                if (runtime_store_1.default.get('context.port.http.' + constants_1.FN_TYPE.basic, false)) {
                    const bioHttpPort = yield port_resolver_1.default.getPort('bio', 'http', {
                        duplicateCheck: false
                    });
                    runtime_store_1.default.set('context.port.http.' + constants_1.FN_TYPE.basic, bioHttpPort);
                }
                break;
            }
            default: {
                throw new error_1.default('Invalid catalyst command', { exit: 2 });
            }
        }
    });
}
exports.resolveAllFnPorts = resolveAllFnPorts;
function fnDirDelete(conf) {
    return __awaiter(this, void 0, void 0, function* () {
        const fnSource = conf.get('functions.source', false);
        if (!fnSource) {
            (0, logger_1.debug)('Unable to get the functions source directory');
            return;
        }
        const fnDir = (0, project_1.resolveProjectPath)(fnSource);
        const dirContents = yield fs_1.ASYNC.walk(fnDir);
        const delFnDir = yield prompt_1.default.ask(prompt_1.default.question('delDir', `All the Catalyst functions configured in the ${constants_1.FILENAME.config} file has been deleted.\n Would you like to delete the ${fnSource} directory too ?`, {
            type: 'confirm',
            when: () => dirContents.length > 0
        }));
        if (delFnDir.delDir === undefined ||
            (typeof delFnDir.delDir === 'boolean' && delFnDir.delDir)) {
            yield fs_1.ASYNC.deleteDir(fnDir);
        }
        return conf.unset('functions');
    });
}
function deleteFunctionLocal(path) {
    return __awaiter(this, void 0, void 0, function* () {
        const isDirectory = yield fs_1.ASYNC.dirExists(path);
        const conf = runtime_store_1.default.get('config');
        if (isDirectory) {
            yield fs_1.ASYNC.deleteDir(path);
        }
        const fnTargets = conf.get('functions.targets').filter((fn) => (typeof fn === 'string' ? !path.endsWith(fn) : !path.endsWith(fn.source)));
        fnTargets.length === 0 ? yield fnDirDelete(conf) : conf.set('functions.targets', fnTargets);
        return conf.syncSave();
    });
}
exports.deleteFunctionLocal = deleteFunctionLocal;
function getSDK(fnType, dest, stack, options = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        const sdk = yield (0, endpoints_1.sdkAPI)();
        let sdkZip;
        switch (stack) {
            case 'java': {
                sdkZip = yield sdk.java(fnType, options.service);
                break;
            }
            default: {
                throw new error_1.default('Unable to determine the sdk stack', { exit: 2 });
            }
        }
        yield new archiver_1.default()
            .load(sdkZip)
            .extract(dest, new RegExp(`catalyst-${stack}`), { ignoreInitial: true })
            .finalize();
    });
}
exports.getSDK = getSDK;
function updateFnConfig(target) {
    return __awaiter(this, void 0, void 0, function* () {
        const targetConfig = target.configuration;
        (0, logger_1.message)('Current memory configuration: ' + (0, ansi_colors_1.bold)(targetConfig.memory + ' MB'));
        const memOption = (0, option_1.getOptionValue)('memory', false);
        const memoryPrompt = yield prompt_1.default.ask(prompt_1.default.question('memory', 'Please specify the memory in MB to configure: ', {
            defaultAns: 256,
            when: () => !memOption,
            validate: (ans) => {
                if (parseInt(ans)) {
                    return true;
                }
                return 'Please specify a valid number';
            }
        }));
        const memValue = memoryPrompt.memory
            ? parseInt(memoryPrompt.memory)
            : parseInt(memOption);
        if (!memValue) {
            throw new error_1.default('value not a number', {
                exit: 1,
                errorId: 'COMMON-5',
                arg: [ansi_colors_1.bold.red(memOption + ''), (0, ansi_colors_1.bold)('--memory')]
            });
        }
        const consent = yield prompt_1.default.ask(prompt_1.default.question('confirm', `Do you want to update the memory configuration for the function ${target.name}(${target.id}) from ${targetConfig.memory + ' MB'} to ${memValue + ' MB ?'}`, {
            type: 'confirm',
            when: () => memValue !== targetConfig.memory
        }));
        if (consent.confirm === undefined) {
            (0, logger_1.success)('Resource already configured with the same value');
            return;
        }
        if (consent.confirm === false) {
            (0, logger_1.error)('Operation aborted by user');
            return;
        }
        if (target.type === constants_1.FN_TYPE.advanced) {
            yield (yield (0, endpoints_1.applogicAPI)()).deploy(undefined, {
                name: target.name,
                stack: target.stack,
                memory: memValue
            });
        }
        else {
            yield (yield (0, endpoints_1.functionsAPI)()).deploy(undefined, {
                name: target.name,
                stack: target.stack,
                type: target.type,
                memory: memValue
            });
        }
        (0, logger_1.success)(`Memory configuration for function ${(0, ansi_colors_1.bold)(target.name)}(${target.id}) has been updated to ${(0, ansi_colors_1.bold)(memValue + ' MB')}`);
    });
}
exports.updateFnConfig = updateFnConfig;
function copyModDirPerm(src, dest, perm, { replace = true } = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        const srcContents = yield fs_1.ASYNC.walk(src, { includeDirPaths: true, depth: 1 });
        srcContents.shift();
        yield Promise.all(srcContents.map((content) => {
            return new Promise((res, rej) => __awaiter(this, void 0, void 0, function* () {
                try {
                    const isDir = content.stats.isDirectory();
                    if (isDir) {
                        const destFolder = (0, path_1.join)(dest, (0, path_1.basename)(content.path));
                        yield fs_1.ASYNC.ensureDir(destFolder);
                        yield copyModDirPerm(content.path, destFolder, perm);
                        return res();
                    }
                    const destFile = (0, path_1.join)(dest, (0, path_1.basename)(content.path));
                    yield fs_1.ASYNC.copyFile(content.path, destFile, replace ? fs_2.constants.COPYFILE_FICLONE : fs_2.constants.COPYFILE_EXCL).catch((err) => {
                        if (!replace && err.code === 'EEXIST') {
                            return;
                        }
                        throw err;
                    });
                    yield fs_1.ASYNC.chmod(destFile, perm);
                    return res();
                }
                catch (e) {
                    rej(e);
                }
            }));
        }));
        return fs_1.ASYNC.chmod(dest, perm);
    });
}
exports.copyModDirPerm = copyModDirPerm;
