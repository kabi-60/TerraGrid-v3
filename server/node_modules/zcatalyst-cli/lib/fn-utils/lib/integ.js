"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.copyIntegHandlers = exports.integHelper = void 0;
const ansi_colors_1 = require("ansi-colors");
const path_1 = require("path");
const error_1 = __importDefault(require("../../error"));
const prompt_1 = __importDefault(require("../../prompt"));
const runtime_store_1 = __importDefault(require("../../runtime-store"));
const constants_1 = require("../../util_modules/constants");
const runtime_1 = __importDefault(require("../../util_modules/constants/lib/runtime"));
const fs_1 = require("../../util_modules/fs");
const js_1 = require("../../util_modules/js");
const serviceChoiceMap = {
    [constants_1.INTEG.services.cliq]: prompt_1.default.choice('Cliq', {
        value: constants_1.INTEG.services.cliq,
        short: 'Cliq'
    }),
    [constants_1.INTEG.services.convokraft]: prompt_1.default.choice(constants_1.INTEG.services.convokraft, {
        value: constants_1.INTEG.services.convokraft,
        short: constants_1.INTEG.services.convokraft
    })
};
function integHelper(services) {
    return __awaiter(this, void 0, void 0, function* () {
        const serviceChoices = services.map((service) => serviceChoiceMap[service]);
        if (serviceChoices.length === 0) {
            throw new error_1.default(`Invalid integration services: [${services.join(',')}]`, {
                exit: 2
            });
        }
        const serviceAns = yield prompt_1.default.ask(prompt_1.default.question('service', 'Select one of the services to continue:', {
            type: 'list',
            choices: serviceChoices
        }));
        runtime_store_1.default.set('context.functions.integration.service', serviceAns.service);
        switch (serviceAns.service) {
            case constants_1.INTEG.services.cliq:
                const handlerChoice = constants_1.CLIQ.component_handlers.map((handler) => {
                    return prompt_1.default.choice(handler, {
                        value: handler,
                        short: handler,
                        checked: true
                    });
                });
                const handlerSelection = yield prompt_1.default.ask(prompt_1.default.question('selectionAnswer', 'Pick the handlers to be initialised', {
                    type: 'checkbox',
                    choices: handlerChoice,
                    validate: (ansArr) => {
                        if (js_1.JS.isEmpty(ansArr)) {
                            return ('Must select at least one handler.\n' +
                                '(Press ' +
                                (0, ansi_colors_1.cyan)('<space>') +
                                ' to select, ' +
                                (0, ansi_colors_1.cyan)('<a>') +
                                ' to toggle all, ' +
                                (0, ansi_colors_1.cyan)('<i>') +
                                ' to invert selection)');
                        }
                        return true;
                    }
                }));
                runtime_store_1.default.set('context.function.integration.cliq.handlers', handlerSelection.selectionAnswer);
                break;
            default:
                break;
        }
    });
}
exports.integHelper = integHelper;
function copyIntegHandlers(templatePath, targetPath, lang) {
    return __awaiter(this, void 0, void 0, function* () {
        const service = runtime_store_1.default.get('context.functions.integration.service', false);
        if (!service) {
            throw new error_1.default('Unable to get service from runtime', { exit: 2 });
        }
        const integ_config = { service };
        switch (service) {
            case constants_1.INTEG.services.cliq:
                const handlers = runtime_store_1.default.get('context.function.integration.cliq.handlers', []);
                if (lang === runtime_1.default.language.node.value) {
                    const filePaths = constants_1.CLIQ.node_template_contents_initial_copy.map((path) => (0, path_1.join)(templatePath, path));
                    yield fs_1.ASYNC.copyFiles(filePaths, targetPath);
                    const integHandlerConfig = {};
                    const handlerPaths = handlers.map((handler) => {
                        integHandlerConfig[handler] = (0, path_1.join)(constants_1.CLIQ.node_handlers_path, constants_1.CLIQ.node_handler_file_mapping[handler]);
                        return (0, path_1.join)(templatePath, constants_1.CLIQ.node_handlers_template_dir, constants_1.CLIQ.node_handler_file_mapping[handler]);
                    });
                    yield fs_1.ASYNC.copyFiles(handlerPaths, (0, path_1.join)(targetPath, constants_1.CLIQ.node_handlers_template_dir));
                    integ_config.handlers = integHandlerConfig;
                }
                else if (lang === runtime_1.default.language.java.value) {
                    const filePaths = constants_1.CLIQ.java_template_contents_initial_copy.map((path) => (0, path_1.join)(templatePath, path));
                    yield fs_1.ASYNC.copyFiles(filePaths, targetPath);
                    const integHandlerConfig = {};
                    const handlerPaths = handlers.map((handler) => {
                        integHandlerConfig[handler] =
                            constants_1.CLIQ.java_handlers_path +
                                constants_1.CLIQ.java_handler_file_mapping[handler].replace('.java', '');
                        return (0, path_1.join)(templatePath, constants_1.CLIQ.java_handlers_template_dir, constants_1.CLIQ.java_handler_file_mapping[handler]);
                    });
                    yield fs_1.ASYNC.copyFiles(handlerPaths, (0, path_1.join)(targetPath, constants_1.CLIQ.java_handlers_template_dir));
                    integ_config.handlers = integHandlerConfig;
                }
                else if (lang === runtime_1.default.language.python.value) {
                    const filePaths = constants_1.CLIQ.python_template_contents_initial_copy.map((path) => (0, path_1.join)(templatePath, path));
                    yield fs_1.ASYNC.copyFiles(filePaths, targetPath);
                    const handlerPaths = handlers.map((handler) => (0, path_1.join)(templatePath, constants_1.CLIQ.python_handlers_template_dir, constants_1.CLIQ.python_handler_file_mapping[handler]));
                    yield fs_1.ASYNC.copyFiles(handlerPaths, (0, path_1.join)(targetPath, constants_1.CLIQ.python_handlers_template_dir));
                }
                break;
            case constants_1.INTEG.services.convokraft: {
                yield fs_1.ASYNC.copyDir(templatePath, targetPath);
                break;
            }
            default:
                break;
        }
        const configString = JSON.stringify([integ_config], null, '\t').replace(new RegExp('\n', 'g'), '\n\t\t');
        runtime_store_1.default.set('context.functions.integration.config', configString);
    });
}
exports.copyIntegHandlers = copyIntegHandlers;
