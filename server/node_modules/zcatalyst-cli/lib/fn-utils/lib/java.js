'use strict';
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getTargetVersion = exports.getTemplatePath = exports.validate = exports.extractAllData = exports.projectFileValidation = exports.ensureJavaInvoker = exports.compileTarget = exports.normaliseClasspath = exports.rewriteClasspath = exports.isValidClassName = exports.containsKeyWord = exports.classPathSep = exports.FN_TYPE = void 0;
const ansi_colors_1 = require("ansi-colors");
const path_1 = require("path");
const xml2js_1 = __importDefault(require("xml2js"));
const error_1 = __importDefault(require("../../error"));
const runtime_store_1 = __importDefault(require("../../runtime-store"));
const config_1 = require("../../util_modules/config");
const constants_1 = require("../../util_modules/constants");
const env_1 = require("../../util_modules/env");
const fs_1 = require("../../util_modules/fs");
const js_1 = require("../../util_modules/js");
const option_1 = require("../../util_modules/option");
const shell_1 = require("../../util_modules/shell");
const userConfig_1 = __importDefault(require("../../userConfig"));
const logger_1 = require("../../util_modules/logger");
const ensure_java_userconfig_1 = require("./ensure-java-userconfig");
var constants_2 = require("../../util_modules/constants");
Object.defineProperty(exports, "FN_TYPE", { enumerable: true, get: function () { return constants_2.FN_TYPE; } });
const keyWords = [
    'abstract',
    'assert',
    'boolean',
    'break',
    'byte',
    'case',
    'catch',
    'char',
    'class',
    'const',
    'continue',
    'default',
    'do',
    'double',
    'else',
    'enum',
    'extends',
    'false',
    'final',
    'finally',
    'float',
    'for',
    'goto',
    'if',
    'implements',
    'import',
    'instanceof',
    'int',
    'interface',
    'long',
    'native',
    'new',
    'null',
    'package',
    'private',
    'protected',
    'public',
    'return',
    'short',
    'static',
    'strictfp',
    'super',
    'switch',
    'synchronized',
    'this',
    'throw',
    'throws',
    'transient',
    'true',
    'try',
    'void',
    'volatile',
    'while'
];
const warningMessages = [
    'warning: [options] bootstrap class path not set in conjunction with -source 8',
    'warning: [options] system modules path not set in conjunction with -source 11'
];
exports.classPathSep = env_1.isWindows ? ';' : ':';
function containsKeyWord(name) {
    return keyWords.some((keyWord) => {
        if (name === keyWord ||
            js_1.JS.endsWith(name, '.' + keyWord) ||
            js_1.JS.startsWith(name, keyWord + '.') ||
            js_1.JS.includes(name, '.' + keyWord + '.')) {
            return true;
        }
        return false;
    });
}
exports.containsKeyWord = containsKeyWord;
function isValidClassName(name) {
    if (name === '') {
        return false;
    }
    if (js_1.JS.upperFirst(name) !== name) {
        return false;
    }
    if (containsKeyWord(name)) {
        return false;
    }
    return true;
}
exports.isValidClassName = isValidClassName;
function rewriteClasspath(pth, libPth) {
    return __awaiter(this, void 0, void 0, function* () {
        yield fs_1.ASYNC.ensureDir(libPth);
        const content = yield fs_1.ASYNC.readFile(pth);
        if (content === undefined) {
            throw new error_1.default('Content of ' + pth + ' is not defined', { exit: 2 });
        }
        const files = yield fs_1.ASYNC.walk((0, path_1.dirname)(libPth), {
            filter: { exclude: ['**/.output'], excludeDir: true }
        });
        const result = yield xml2js_1.default.parseStringPromise(content);
        const classPathEntries = js_1.JS.chain(files)
            .filter((jar) => (0, path_1.extname)(jar.path) === '.jar')
            .map((jar) => {
            return {
                $: {
                    kind: 'lib',
                    path: (0, path_1.basename)((0, path_1.dirname)(jar.path)) === 'lib'
                        ? 'lib/' + (0, path_1.basename)(jar.path)
                        : (0, path_1.basename)(jar.path)
                }
            };
        })
            .concat(js_1.JS.get(result, 'classpath.classpathentry', []))
            .uniq()
            .value();
        js_1.JS.set(result, 'classpath.classpathentry', classPathEntries);
        const builder = new xml2js_1.default.Builder();
        return fs_1.ASYNC.writeFile(pth, builder.buildObject(result));
    });
}
exports.rewriteClasspath = rewriteClasspath;
function normaliseClasspath(pth, libFolder) {
    return __awaiter(this, void 0, void 0, function* () {
        const content = yield fs_1.ASYNC.readFile(pth);
        if (content === undefined) {
            throw new error_1.default('Content of ' + pth + ' is not defined', { exit: 2 });
        }
        const result = yield xml2js_1.default.parseStringPromise(content);
        const classPathEntries = js_1.JS.get(result, 'classpath.classpathentry', []);
        const jarFilesList = [];
        yield Promise.all(classPathEntries.map((entry) => __awaiter(this, void 0, void 0, function* () {
            const row = entry.$;
            if (row.kind && row.kind === 'lib' && row.path) {
                const libPath = (0, path_1.resolve)((0, path_1.dirname)(pth), row.path);
                const jarName = (0, path_1.basename)(libPath);
                const jarExists = yield fs_1.ASYNC.fileExists((0, path_1.join)(libFolder, jarName));
                if (!jarExists) {
                    try {
                        yield fs_1.ASYNC.copyFile(libPath, (0, path_1.join)(libFolder, jarName));
                    }
                    catch (err) {
                        throw new error_1.default(libPath + ' mentioned in .classpath file missing', {
                            exit: 1,
                            errorId: 'JAVA-1',
                            original: err,
                            arg: [(0, ansi_colors_1.bold)(libPath), (0, ansi_colors_1.bold)('.classpath')]
                        });
                    }
                }
                row.path = (0, path_1.basename)(libFolder) + '/' + jarName;
                if ((0, path_1.dirname)(libPath) === (0, path_1.dirname)(libFolder)) {
                    try {
                        yield fs_1.ASYNC.deleteFile(libPath);
                    }
                    catch (err) {
                        throw new error_1.default(libPath +
                            ' mentioned in .classpath file missing. The .classpath file in the target directory seems to be corrupted.', {
                            exit: 1,
                            errorId: 'JAVA-2',
                            original: err,
                            arg: [(0, ansi_colors_1.bold)('.classpath'), (0, ansi_colors_1.bold)((0, path_1.dirname)(pth))]
                        });
                    }
                }
                jarFilesList.push((0, path_1.join)(libFolder, jarName));
            }
        })));
        js_1.JS.set(result, 'classpath.classpathentry', classPathEntries);
        runtime_store_1.default.set('context.functions.java.libJarFiles', jarFilesList);
        const builder = new xml2js_1.default.Builder();
        return fs_1.ASYNC.writeFile(pth, builder.buildObject(result));
    });
}
exports.normaliseClasspath = normaliseClasspath;
function compileTarget(target) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        const targetSource = target.source;
        const outputFolder = (0, path_1.join)(targetSource, constants_1.FOLDERNAME.output);
        const integ = target.integ_config;
        const entries = [(0, path_1.join)(targetSource, ((_a = target.index) === null || _a === void 0 ? void 0 : _a.replace(/\./g, path_1.sep)) + '.java')];
        const configKey = `${target.stack}.bin`;
        const userConfigCmd = userConfig_1.default.get(configKey);
        const spawnCommand = (0, ensure_java_userconfig_1.getJavaSpawnCommand)(userConfigCmd, 'javac', target.stack);
        if (integ && integ.length > 0) {
            integ.forEach((integConf) => {
                const handlers = integConf.handlers;
                handlers &&
                    Object.keys(handlers).forEach((handler) => {
                        entries.push((0, path_1.join)(targetSource, handlers[handler].replace(/\./g, path_1.sep) + '.java'));
                    });
            });
        }
        yield fs_1.ASYNC.ensureDir(outputFolder);
        yield fs_1.ASYNC.emptyDir(outputFolder);
        const ignore = config_1.functionsConfig.ignore(targetSource);
        const allFiles = yield fs_1.ASYNC.walk(targetSource, {
            filter: { exclude: ['**/.output', ...ignore], excludeDir: true }
        });
        const cleanUpFiles = allFiles.map((file) => file.path);
        while (allFiles.length > 0) {
            const limit = allFiles.length < 20 ? allFiles.length : 20;
            yield Promise.all(allFiles.splice(0, limit).map((file) => {
                const targetPth = file.path.includes(path_1.sep + 'lib' + path_1.sep)
                    ? file.path.replace(targetSource + path_1.sep + 'lib', '')
                    : file.path.replace(targetSource, '');
                return fs_1.ASYNC.copyFile(file.path, (0, path_1.join)(outputFolder, targetPth));
            }));
        }
        const targetVersion = getTargetVersion(target.stack);
        yield Promise.all(entries.map((file) => compileJavaFiles(file, spawnCommand, targetVersion, targetSource, outputFolder)
            .then((result) => {
            const [_stdout, stderr, code] = result;
            if (code === null || code >= 1) {
                const error = [];
                error === null || error === void 0 ? void 0 : error.push(stderr);
                target.valid = false;
                target.failure_reason = 'there was a Java compilation error';
                target.compilationError = error;
            }
            else if (stderr) {
                target.compilationWarning = [stderr];
            }
        })
            .catch((error) => {
            target.valid = false;
            target.failure_reason = error.message;
        })));
        const currentCommand = (0, option_1.getCurrentCommand)();
        switch (currentCommand) {
            case 'pull':
            case 'init':
                yield cleanUp(cleanUpFiles);
                break;
            case 'deploy':
                const classPath = (0, path_1.join)(outputFolder, constants_1.FILENAME.functions.java_classpath);
                if (yield fs_1.ASYNC.fileExists(classPath)) {
                    const classPathFile = yield fs_1.ASYNC.readFile(classPath);
                    if (classPathFile) {
                        yield fs_1.ASYNC.writeFile(classPath, classPathFile.replace(/lib[\\|\/]/g, ''));
                    }
                }
                break;
        }
    });
}
exports.compileTarget = compileTarget;
function compileJavaFiles(file, spawnCommand, targetVersion, targetSource, outputFolder) {
    return __awaiter(this, void 0, void 0, function* () {
        (0, logger_1.info)('Compiling ' + file);
        return new Promise((resolve, reject) => {
            var _a, _b;
            const child = (0, shell_1.spawn)(spawnCommand, [
                '-target',
                targetVersion,
                '-source',
                targetVersion,
                '-cp',
                '*' + module.exports.classPathSep + '.',
                '-g',
                '-Xprefer:source',
                '-Xlint',
                file.replace(targetSource, outputFolder)
            ], {
                cwd: outputFolder,
                stdio: 'pipe'
            }).RAW();
            let stdout = '';
            let stderr = '';
            (_a = child.stdout) === null || _a === void 0 ? void 0 : _a.on('data', (data) => {
                stdout += data.toString();
            });
            (_b = child.stderr) === null || _b === void 0 ? void 0 : _b.on('data', (data) => {
                const err = data.toString();
                let newErr = '';
                warningMessages.forEach((element) => {
                    if (err.includes(element)) {
                        newErr += err.replace(element, '');
                    }
                });
                if (!newErr) {
                    newErr += err;
                }
                stderr += newErr;
            });
            child.on('error', (error) => {
                reject(error);
            });
            child.on('close', (code) => {
                resolve([stdout, stderr, code]);
            });
        });
    });
}
function ensureJavaInvoker(pth, invoker, target) {
    const configKey = `${target.stack}.bin`;
    const userConfigCmd = userConfig_1.default.get(configKey);
    const spawnCommand = (0, ensure_java_userconfig_1.getJavaSpawnCommand)(userConfigCmd, 'javac', target.stack);
    const classPth = pth + '.class';
    const targetVersion = getTargetVersion(target.stack);
    if (fs_1.SYNC.fileExists(classPth)) {
        return true;
    }
    fs_1.SYNC.ensureDir((0, path_1.dirname)(classPth));
    const child = (0, shell_1.spawn)(spawnCommand, [
        '-target',
        targetVersion,
        '-source',
        targetVersion,
        '-cp',
        (0, path_1.join)('lib', '*') + module.exports.classPathSep + '.',
        '-g',
        '-d',
        (0, path_1.dirname)(classPth),
        (0, path_1.basename)(invoker)
    ], { cwd: (0, path_1.dirname)(invoker), stdio: 'pipe' }).SYNC();
    if (child.status === 1) {
        const errorResponse = [];
        const err = child.stderr.toString();
        warningMessages.forEach((element) => {
            if (err.includes(element)) {
                errorResponse.push(err.replace(element, ''));
            }
        });
        target.compilationError = errorResponse;
    }
    fs_1.SYNC.copyDir((0, path_1.join)((0, path_1.dirname)(invoker), 'lib'), (0, path_1.join)((0, path_1.dirname)(classPth), 'lib'));
    return true;
}
exports.ensureJavaInvoker = ensureJavaInvoker;
function projectFileValidation(pth, target) {
    var _a, _b;
    return __awaiter(this, void 0, void 0, function* () {
        const fileExists = yield fs_1.ASYNC.fileExists(pth);
        if (!fileExists) {
            const templatePath = getTemplatePath(target.type, (_b = (_a = target.integ_config) === null || _a === void 0 ? void 0 : _a.at(0)) === null || _b === void 0 ? void 0 : _b.service);
            yield fs_1.ASYNC.copyFile((0, path_1.join)(templatePath, constants_1.FILENAME.functions.java_project), (0, path_1.join)(target.source, constants_1.FILENAME.functions.java_project));
            yield fs_1.ASYNC.findAndReplace(pth)(constants_1.PLACEHOLDER.functions.java_name, target.name);
        }
        const content = yield fs_1.ASYNC.readFile(pth);
        if (content === undefined) {
            throw new error_1.default('Content of ' + pth + ' is undefined', { exit: 2 });
        }
        const result = yield xml2js_1.default.parseStringPromise(content);
        const name = js_1.JS.get(result, 'projectDescription.name')[0];
        if (name !== target.name) {
            throw new error_1.default('project name mismatch in .project file for function ' + target.name, {
                exit: 1,
                errorId: 'JAVA-3',
                arg: [(0, ansi_colors_1.bold)(name), (0, ansi_colors_1.bold)((0, path_1.basename)(pth)), (0, ansi_colors_1.bold)(target.name)]
            });
        }
    });
}
exports.projectFileValidation = projectFileValidation;
function extractAllData(child, name) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((res, rej) => {
            var _a, _b, _c;
            let message = '';
            (_a = child[name]) === null || _a === void 0 ? void 0 : _a.on('data', (chunk) => {
                message += chunk;
            });
            (_b = child[name]) === null || _b === void 0 ? void 0 : _b.on('end', () => {
                res(message);
            });
            (_c = child[name]) === null || _c === void 0 ? void 0 : _c.on('error', (err) => {
                rej(err);
            });
        });
    });
}
exports.extractAllData = extractAllData;
function validate(targets, idx) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        if (targets.length < idx + 1) {
            return;
        }
        const currentTarget = targets[idx];
        try {
            const targetSource = currentTarget.source;
            const classpath = (0, path_1.join)(targetSource, constants_1.FILENAME.functions.java_classpath);
            const projectPath = (0, path_1.join)(targetSource, constants_1.FILENAME.functions.java_project);
            const libFolder = (0, path_1.join)(targetSource, 'lib');
            const entry = (0, path_1.join)(targetSource, ((_a = currentTarget.index) === null || _a === void 0 ? void 0 : _a.replace(/\./g, path_1.sep)) + '.java');
            const entryFileExists = yield fs_1.ASYNC.fileExists(entry);
            const classPathExists = yield fs_1.ASYNC.fileExists(classpath);
            if (!entryFileExists) {
                throw new error_1.default((0, path_1.basename)(entry) + ' file is missing', {
                    exit: 1,
                    errorId: 'JAVA-6',
                    arg: [
                        (0, ansi_colors_1.bold)((0, path_1.basename)(entry)),
                        (0, ansi_colors_1.bold)(constants_1.FILENAME.catalyst_config),
                        (0, ansi_colors_1.bold)(currentTarget.name)
                    ]
                });
            }
            if (!classPathExists) {
                const templatePath = getTemplatePath(currentTarget.type);
                yield fs_1.ASYNC.copyFile((0, path_1.join)(templatePath, constants_1.FILENAME.functions.java_classpath), (0, path_1.join)(targetSource, constants_1.FILENAME.functions.java_classpath));
                yield rewriteClasspath(classpath, libFolder);
            }
            yield normaliseClasspath(classpath, libFolder);
            yield projectFileValidation(projectPath, currentTarget);
            yield (0, ensure_java_userconfig_1.ensureJava)(currentTarget);
            yield compileTarget(currentTarget).catch((err) => {
                throw new error_1.default('there was a compilation error!', {
                    exit: 1,
                    errorId: 'JAVA-7',
                    original: err,
                    skipHelp: !!(0, option_1.getOptionValue)('watch', false)
                });
            });
            return validate(targets, ++idx);
        }
        catch (err) {
            currentTarget.valid = false;
            currentTarget.failure_reason = err.message;
            return validate(targets, ++idx);
        }
    });
}
exports.validate = validate;
function cleanUp(files) {
    return __awaiter(this, void 0, void 0, function* () {
        const promiseArr = [];
        const deleteArr = [];
        const hashes = {};
        files.forEach((file, idx) => {
            if (file.endsWith('.java')) {
                const hash = hashes[file];
                if (hash === undefined) {
                    hashes[file] = { found: true, acc: [] };
                }
                else {
                    hash.found = true;
                    deleteArr.push(...hash.acc);
                }
            }
            else if (file.endsWith('.class')) {
                const javaFile = file.replace(new RegExp('(\\$+[0-9]+)?\\.class$', 'g'), '.java');
                const hashValue = hashes[javaFile];
                if (hashValue === undefined) {
                    hashes[javaFile] = { found: false, acc: [file] };
                }
                else if (hashValue.found === true) {
                    files.splice(idx, 1);
                    promiseArr.push(fs_1.ASYNC.deleteFile(file));
                }
                else if (hashValue.found === false) {
                    hashValue.acc.push(file);
                }
            }
        });
        return Promise.all([...deleteArr.map((file) => fs_1.ASYNC.deleteFile(file)), ...promiseArr]);
    });
}
function getTemplatePath(fnType, add) {
    switch (fnType) {
        case constants_1.FN_TYPE.browserLogic: {
            if (Object.keys(constants_1.TEMPLATE.functions.java.browserlogic).includes('Selenium')) {
                return constants_1.TEMPLATE.functions.java.browserlogic.Selenium;
            }
            throw new error_1.default('Invalid browserlogic type', { exit: 2 });
        }
        case constants_1.FN_TYPE.integration: {
            if (!add) {
                throw new error_1.default('Invalid additional parameter', { exit: 2 });
            }
            const temp = constants_1.TEMPLATE.functions.java[fnType];
            return temp[add];
        }
        default: {
            return constants_1.TEMPLATE.functions.java[fnType];
        }
    }
}
exports.getTemplatePath = getTemplatePath;
function getTargetVersion(stack) {
    return ensure_java_userconfig_1.stackVsVersions[stack].target;
}
exports.getTargetVersion = getTargetVersion;
