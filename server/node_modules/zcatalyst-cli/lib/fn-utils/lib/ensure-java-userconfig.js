'use strict';
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getJavaSpawnCommand = exports.ensureJava = exports.stackVsVersions = void 0;
const semver_1 = require("semver");
const error_1 = __importDefault(require("../../error"));
const runtime_store_1 = __importDefault(require("../../runtime-store"));
const userConfig_1 = __importDefault(require("../../userConfig"));
const shell_1 = require("../../util_modules/shell");
const java_1 = require("./java");
const path_1 = require("path");
exports.stackVsVersions = {
    java8: {
        version: '1.8.0',
        target: '1.8'
    },
    java11: {
        version: '11.0.0',
        target: '11'
    },
    java17: {
        version: '17.0.0',
        target: '17'
    }
};
function ensureJava(target) {
    return __awaiter(this, void 0, void 0, function* () {
        const configKey = `${target.stack}.bin`;
        const spawnCommand = userConfig_1.default.get(configKey);
        let usingJavaDefaultPath = false;
        if (!spawnCommand) {
            runtime_store_1.default.set(`context.java.isUsingJavaDefaultPath_${target.stack}`, true);
            usingJavaDefaultPath = true;
        }
        let javacVersion = '';
        const currentStackVersion = exports.stackVsVersions[target.stack].version;
        try {
            const javacSpawnCommand = getJavaSpawnCommand(spawnCommand, 'javac', target.stack);
            javacVersion = yield validateJavaPath(javacSpawnCommand);
            if (!javacVersion) {
                if (spawnCommand) {
                    throw new error_1.default(`unable to check the javac version using the given binary path. Kindly re-check. Please provide a valid java binary path for the config key ${target.stack}.bin to serve or deploy the function[${target.name}].`, {
                        exit: 0,
                        errorId: 'JAVACONFIG-1',
                        arg: [
                            target.stack,
                            target.name,
                            `jdk-${exports.stackVsVersions[target.stack]
                                .target}`
                        ]
                    });
                }
                else {
                    throw new error_1.default(`unable to locate the java binary path in your system. Kindly re-check. Please provide the valid java binary path for the config key ${target.stack}.bin to serve or deploy the function[${target.name}].`, {
                        exit: 0,
                        errorId: 'JAVACONFIG-2',
                        arg: [`${target.stack}.bin`, target.name]
                    });
                }
            }
        }
        catch (_a) {
            throw new error_1.default(`error while validating java binary path. Please provide a valid java binary path for the config key ${target.stack}.bin to serve or deploy the function[${target.name}].`, {
                exit: 0,
                errorId: 'JAVACONFIG-4',
                arg: [`${target.stack}.bin`, target.name]
            });
        }
        if ((0, semver_1.satisfies)(currentStackVersion, `>${javacVersion}`)) {
            if (usingJavaDefaultPath === false) {
                throw new error_1.default(`provided JDK version[jdk-${javacVersion}] for the config key ${target.stack}.bin is lesser than the compatible JDK version[jdk-${exports.stackVsVersions[target.stack].target}]. Please provide a valid java binary path for the config key ${target.stack}.bin to serve or deploy the function[${target.name}].`, {
                    exit: 0,
                    skipHelp: true,
                    errorId: 'JAVACONFIG-3',
                    arg: [
                        `jdk-${javacVersion}`,
                        target.stack,
                        `jdk-${exports.stackVsVersions[target.stack].target}`,
                        target.name
                    ]
                });
            }
            throw new error_1.default(`provided JDK version[jdk-${javacVersion}] is lesser than the compatible JDK version[jdk-${exports.stackVsVersions[target.stack].target}]. Please provide a valid java binary path for the config key ${target.stack}.bin to serve or deploy the function[${target.name}].`, {
                exit: 0,
                skipHelp: true,
                errorId: 'JAVACONFIG-3',
                arg: [
                    `jdk-${javacVersion}`,
                    target.stack,
                    `jdk-${exports.stackVsVersions[target.stack].target}`,
                    target.name
                ]
            });
        }
        const majorVersion = target.stack === 'java8' ? '' : currentStackVersion.split('.')[0];
        if (!(((0, semver_1.satisfies)(javacVersion, `>=${majorVersion}.0.0`) &&
            (0, semver_1.satisfies)(javacVersion, `<=${majorVersion}.x.x`)) ||
            (target.stack === 'java8' &&
                (0, semver_1.satisfies)(javacVersion, '>=1.8.0') &&
                (0, semver_1.satisfies)(javacVersion, '<=1.8.x')))) {
            const warningMessage = [];
            warningMessage.push(`Warning : Your function[${target.name}] stack is ${target.stack}. But you are using jdk ${javacVersion} to compile source files. Please use jdk ${exports.stackVsVersions[target.stack].target} for better compilation`);
            target.compilationWarning = warningMessage;
        }
        if (!spawnCommand) {
            runtime_store_1.default.set(`context.java.isUsingJavaDefaultPath_${target.stack}`, true);
        }
    });
}
exports.ensureJava = ensureJava;
function validateJavaPath(spawnCommand) {
    return __awaiter(this, void 0, void 0, function* () {
        const spawnOpts = ['-version'];
        const javacVersionChild = (0, shell_1.spawn)(spawnCommand, spawnOpts, {
            cwd: runtime_store_1.default.get('cwd'),
            stdio: 'pipe'
        }).RAW();
        let javacVersionDetails = yield (0, java_1.extractAllData)(javacVersionChild, 'stdout');
        javacVersionDetails =
            javacVersionDetails === ''
                ? yield (0, java_1.extractAllData)(javacVersionChild, 'stderr')
                : javacVersionDetails;
        const javacVersion = (0, semver_1.valid)((0, semver_1.coerce)(javacVersionDetails.split(' ')[1]));
        return javacVersion;
    });
}
function getJavaSpawnCommand(spawnCommand, process, stack) {
    const isUsingJavaDefaultPath = runtime_store_1.default.get(`context.java.isUsingJavaDefaultPath_${stack}`);
    if (isUsingJavaDefaultPath === true) {
        return process;
    }
    return (0, path_1.join)(spawnCommand, process);
}
exports.getJavaSpawnCommand = getJavaSpawnCommand;
