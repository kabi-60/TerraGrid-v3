'use strict';
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const express_1 = __importDefault(require("express"));
const events_1 = require("events");
const chokidar_1 = require("chokidar");
const logger_js_1 = require("../../../../util_modules/logger.js");
const index_js_1 = require("../../../../util_modules/constants/index.js");
const error_js_1 = __importDefault(require("../../../../error.js"));
const index_js_2 = require("../../../../util_modules/fs/index.js");
const path_1 = require("path");
const ws_1 = require("ws");
const port_resolver_js_1 = __importDefault(require("../../../../port-resolver.js"));
const ansi_colors_1 = require("ansi-colors");
const server_js_1 = require("../../../../util_modules/server.js");
function prepareScriptFile(dir, port) {
    return __awaiter(this, void 0, void 0, function* () {
        const scriptFile = yield index_js_2.ASYNC.readFile(index_js_1.TEMPLATE.client.basic.socket);
        if (!scriptFile) {
            throw new error_js_1.default('Unable to read the script file', { exit: 2 });
        }
        const scriptReady = scriptFile.replace(new RegExp(index_js_1.PLACEHOLDER.client.port, 'g'), port + '');
        yield index_js_2.ASYNC.ensureDir(dir);
        const scriptFilePath = (0, path_1.join)(dir, 'reload-script.js');
        yield index_js_2.ASYNC.writeFile(scriptFilePath, scriptReady);
        return scriptFilePath;
    });
}
function stringInjector(source, anchorIdx, marker, inject) {
    const headLastIdx = anchorIdx + marker.length;
    const scriptPrefix = source.slice(0, headLastIdx);
    const scriptSuffix = source.slice(headLastIdx);
    return scriptPrefix + inject + scriptSuffix;
}
function injectScript(scriptLocale, indexHtml) {
    return __awaiter(this, void 0, void 0, function* () {
        const headIdx = indexHtml.search(/<head>/gi);
        const scriptTag = `\n<!--  Catalyst web client reload script -->\n<script type="text/javascript" src="${scriptLocale}"></script>\n`;
        if (headIdx !== -1) {
            return stringInjector(indexHtml, headIdx, '<head>', scriptTag);
        }
        const htmlIdx = indexHtml.search(/<html>/gi);
        const headTag = `\n<head>${scriptTag}</head>\n`;
        return stringInjector(indexHtml, htmlIdx, '<html>', headTag);
    });
}
function reloadApp(event, path, liveSockets) {
    (0, logger_js_1.info)((0, ansi_colors_1.cyan)(`${event} detected in ${path} of the Web-Client.`));
    liveSockets.forEach((socket) => socket.send('reload'));
}
function webClientServer(httpPort, source, { homepage = 'index.html', enableWatch = true, notFoundPage } = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        const eventListener = new events_1.EventEmitter();
        const catalystTempDir = (0, path_1.join)(source, '.catalyst');
        const socketServerPort = yield port_resolver_js_1.default.getFreePort(httpPort, 20, true);
        const reloadScriptSrc = enableWatch
            ? (0, path_1.relative)(source, yield prepareScriptFile(catalystTempDir, socketServerPort))
            : undefined;
        if (reloadScriptSrc) {
            const clientWatcher = (0, chokidar_1.watch)(source, {
                ignoreInitial: true,
                ignored: ['node_modules/**/*', `/**/${index_js_1.FILENAME.client.package_json}`]
            });
            const liveSockets = [];
            let watcherReady = false;
            clientWatcher.on('error', (err) => {
                watcherReady = false;
                eventListener.emit('error', new error_js_1.default('client watcher error', {
                    original: err,
                    exit: 1,
                    skipHelp: true
                }));
            });
            clientWatcher.on('ready', () => {
                watcherReady = true;
                const socketServer = new ws_1.WebSocketServer({
                    port: socketServerPort,
                    path: '/client-reload'
                })
                    .on('connection', (clientSocket) => {
                    if (!watcherReady) {
                        clientSocket.send('watcher not ready');
                        clientSocket.close();
                        return;
                    }
                    clientSocket.on('close', () => {
                        const socketIdx = liveSockets.findIndex((socket) => socket === clientSocket);
                        liveSockets.splice(socketIdx, 1);
                    });
                    liveSockets.push(clientSocket);
                    clientSocket.send('connected');
                })
                    .on('error', (err) => (0, logger_js_1.debug)(err));
                setTimeout(() => {
                    clientWatcher.on('change', (path) => {
                        reloadApp('Change(s) is', (0, path_1.relative)(source, path), liveSockets);
                    });
                    clientWatcher.on('add', (path) => {
                        reloadApp('Addition of file(s) is', (0, path_1.relative)(source, path), liveSockets);
                    });
                    clientWatcher.on('unlink', (path) => {
                        reloadApp('Deletion of file(s) is', (0, path_1.relative)(source, path), liveSockets);
                    });
                }, 1000);
                eventListener.addListener('close', () => socketServer === null || socketServer === void 0 ? void 0 : socketServer.close());
            });
            eventListener.addListener('close', () => {
                if (clientWatcher) {
                    clientWatcher.close();
                }
                liveSockets.forEach((socket) => socket.close());
                index_js_2.SYNC.deleteDir(catalystTempDir);
            });
        }
        const app = (0, express_1.default)();
        app.use('/app', (req, res) => __awaiter(this, void 0, void 0, function* () {
            const requestedFile = req.url === '/' ? homepage : decodeURIComponent(req.path);
            if (enableWatch && (requestedFile.includes('.html') || requestedFile.includes('.htm'))) {
                const htmlFile = yield index_js_2.ASYNC.readFile((0, path_1.join)(source, requestedFile));
                if (!htmlFile) {
                    res.contentType('text/html');
                    res.status(404);
                    res.end();
                    eventListener.emit('error', new error_js_1.default('Unable to read the html file', {
                        exit: 1,
                        errorId: 'WEB-CLIENT-SERVER-1',
                        arg: [ansi_colors_1.red.italic(requestedFile)]
                    }));
                    return;
                }
                const injectedHtml = reloadScriptSrc
                    ? yield injectScript(encodeURIComponent(reloadScriptSrc), htmlFile)
                    : undefined;
                res.contentType('text/html');
                res.status(200);
                res.send(injectedHtml || htmlFile);
                return;
            }
            res.sendFile((0, path_1.join)(source, requestedFile), (err) => {
                if (!err) {
                    return;
                }
                if (err.code && err.code === 'ENOENT') {
                    (0, logger_js_1.error)((0, ansi_colors_1.red)('[404 - Resource not found]: ') + (0, ansi_colors_1.bold)(requestedFile));
                    (0, logger_js_1.info)();
                    (0, logger_js_1.debug)(err.stack || err.message);
                    res.status(404);
                    notFoundPage
                        ? res.sendFile(notFoundPage, (e) => {
                            if (!e) {
                                return;
                            }
                            (0, logger_js_1.debug)('Unable to send the 404 page to server: ', e);
                            res.status(500);
                            res.send('Error sending 404 page to server: ' + e.stack);
                        })
                        : res.send('Resource not found');
                    return;
                }
                (0, logger_js_1.error)('Error fetching the resource: ' + err);
                (0, logger_js_1.debug)(err.stack);
                res.status(500);
                res.send('Error fetching the resource');
            });
        }));
        const server = app.listen(httpPort, '127.0.0.1').on('error', (err) => {
            eventListener.emit('error', err);
        });
        const expressDestroyer = new server_js_1.ConnectionDestroyer(server);
        eventListener.on('error', (err) => {
            (0, logger_js_1.error)('Error when serving the web-client: ' + err.message);
            (0, logger_js_1.info)('Please exit the command to get more info');
            eventListener.emit('close');
        });
        eventListener.on('close', () => __awaiter(this, void 0, void 0, function* () {
            yield expressDestroyer.destroy();
            (0, logger_js_1.debug)('client server closed');
        }));
        return new Promise((res) => server.on('listening', () => res(eventListener)));
    });
}
exports.default = webClientServer;
