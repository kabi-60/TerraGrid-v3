"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = require("path");
const error_1 = __importDefault(require("../../../../error"));
const constants_1 = require("../../../../util_modules/constants");
const fs_1 = require("../../../../util_modules/fs");
const logger_1 = require("../../../../util_modules/logger");
const project_1 = require("../../../../util_modules/project");
const shell_1 = require("../../../../util_modules/shell");
const endpoints_1 = require("../../../../endpoints");
const archiver_1 = __importDefault(require("../../../../archiver"));
const option_1 = require("../../../../util_modules/option");
const execute_script_1 = require("../../../../execute-script");
const master_1 = __importDefault(require("../master"));
const ansi_colors_1 = require("ansi-colors");
function executeHook(script, name, moduleSource) {
    if ((0, option_1.getOptionValue)('ignoreScripts', false)) {
        (0, logger_1.debug)(`skipping ${name} hook`);
        return;
    }
    (0, execute_script_1.executeCommand)(script, { moduleSource, feature: name });
}
const startAppSail = (port, opts) => {
    const startScriptPath = (0, path_1.join)(__dirname, 'start.js');
    const _opts = [startScriptPath, '-t', opts.type];
    if (opts.command) {
        _opts.push('-c', opts.command);
    }
    return (0, shell_1.spawn)('node', _opts, {
        cwd: opts.target,
        stdio: 'pipe',
        env: Object.assign({ X_ZOHO_CATALYST_LISTEN_PORT: port + '', X_ZOHO_CATALYST_RUNTIME_MEMORY: opts.memory + '', X_ZOHO_CATALYST_ACCOUNTS_URL: constants_1.ORIGIN.auth, X_ZOHO_CATALYST_CONSOLE_URL: constants_1.ORIGIN.admin, CATALYST_PROJECT_TIMEZONE: (0, project_1.getProjectTimezone)(Intl.DateTimeFormat().resolvedOptions().timeZone) }, (opts.env || {}))
    }).RAW();
};
exports.default = (serverDetails) => __awaiter(void 0, void 0, void 0, function* () {
    var _a, _b, _c, _d;
    let child;
    const targetSail = serverDetails.target;
    if (!targetSail || !targetSail.appSail) {
        throw new error_1.default('AppSail details not found');
    }
    if ((_a = targetSail.appSail.scripts) === null || _a === void 0 ? void 0 : _a.preserve) {
        executeHook(targetSail.appSail.scripts.preserve, `AppSail [PRESERVE] [${(_b = targetSail.appSail) === null || _b === void 0 ? void 0 : _b.name}]`, targetSail.appSail.source);
    }
    const buildPath = targetSail.appSail.buildPath
        ? targetSail.appSail.buildPath
        : (_c = targetSail.appSail) === null || _c === void 0 ? void 0 : _c.build_path;
    if (!(yield fs_1.ASYNC.isPathExists(buildPath))) {
        throw new error_1.default(`Build path does not exists [${buildPath}]`, {
            exit: 1,
            errorId: 'SERVE-APPSAIL-1',
            arg: [ansi_colors_1.italic.red(buildPath), (0, ansi_colors_1.bold)(targetSail.appSail.name)]
        });
    }
    const target = (yield fs_1.ASYNC.fileExists(buildPath)) ? (0, path_1.dirname)(buildPath) : buildPath;
    switch (true) {
        case targetSail.appSail.stack.startsWith('node'): {
            child = startAppSail(targetSail.port.appsail, {
                type: 'nodejs',
                target,
                command: targetSail.appSail.command,
                memory: targetSail.appSail.memory || 256,
                env: targetSail.appSail.env_variables
            });
            break;
        }
        case targetSail.appSail.stack.startsWith('python'): {
            child = startAppSail(targetSail.port.appsail, {
                type: 'python',
                target,
                command: targetSail.appSail.command,
                memory: targetSail.appSail.memory || 256,
                env: targetSail.appSail.env_variables
            });
            break;
        }
        case targetSail.appSail.stack.startsWith('java'): {
            if (targetSail.appSail.platform === 'war') {
                const jettyPath = (0, path_1.join)(constants_1.ENVPATH.runtimes.data, 'jetty');
                if (!(yield fs_1.ASYNC.fileExists((0, path_1.join)(jettyPath, 'start.jar')).catch((err) => (0, logger_1.debug)(err)))) {
                    try {
                        yield fs_1.ASYNC.ensureDir(jettyPath);
                        const appxAPI = yield (0, endpoints_1.appSailAPI)();
                        const jettyZip = yield appxAPI.downloadJetty();
                        const zip = new archiver_1.default();
                        zip.load(jettyZip);
                        zip.extract(jettyPath, '/', {
                            ignoreInitial: false,
                            isFolder: true
                        });
                        yield zip.finalize();
                    }
                    catch (err) {
                        (0, logger_1.debug)('Unable to ensure Jetty Runtime');
                        throw err;
                    }
                }
                const jettyCommand = `java -jar "${(0, path_1.join)(jettyPath, 'start.jar')}" -Djetty.deploy.monitoredPath="${(0, project_1.resolveProjectPath)(target)}" -Djetty.http.port=${targetSail.port.appsail}`;
                child = startAppSail(targetSail.port.appsail, {
                    target,
                    type: 'war',
                    command: jettyCommand,
                    memory: targetSail.appSail.memory || 256,
                    env: Object.assign({ JETTY_BASE: (0, path_1.join)(jettyPath, 'JETTY_BASE') }, targetSail.appSail.env_variables)
                });
                break;
            }
            child = startAppSail(targetSail.port.appsail, {
                target,
                command: targetSail.appSail.command,
                type: 'javase',
                memory: targetSail.appSail.memory || 256,
                env: targetSail.appSail.env_variables
            });
            break;
        }
        default: {
            throw new error_1.default('Invalid AppSail stack');
        }
    }
    const masterServe = yield (0, master_1.default)(targetSail.port.proxy, {
        appSail: [serverDetails]
    });
    child.once('exit', () => {
        masterServe.close((err) => {
            if (err) {
                (0, logger_1.debug)('Error stopping the AppSail proxy server: ', err);
            }
        });
    });
    if ((_d = targetSail.appSail.scripts) === null || _d === void 0 ? void 0 : _d.postserve) {
        child.once('exit', () => {
            var _a, _b, _c, _d;
            if (!((_a = targetSail.appSail) === null || _a === void 0 ? void 0 : _a.scripts)) {
                return;
            }
            executeHook((_b = targetSail.appSail.scripts) === null || _b === void 0 ? void 0 : _b.postserve, `AppSail [POSTSERVE] [${(_c = targetSail.appSail) === null || _c === void 0 ? void 0 : _c.name}]`, (_d = targetSail.appSail) === null || _d === void 0 ? void 0 : _d.source);
        });
    }
    return child;
});
