"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CodeDeckToken = exports.getDeckFromGit = exports.getTemplateFile = exports.listenDeploy = void 0;
const archiver_1 = __importDefault(require("./archiver"));
const endpoints_1 = require("./endpoints");
const error_1 = __importDefault(require("./error"));
const prompt_1 = __importDefault(require("./prompt"));
const tree_1 = require("./prompt/types/tree");
const runtime_store_1 = __importDefault(require("./runtime-store"));
const logger_1 = require("./util_modules/logger");
const shell_1 = require("./util_modules/shell");
function listenDeploy(id, gitUrl) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const allGlobalOpts = runtime_store_1.default.get('opts.globalOpts', {});
            const optsArr = Object.keys(allGlobalOpts).reduce((arr, key) => {
                arr.push('--' + key);
                if (allGlobalOpts[key]) {
                    arr.push(allGlobalOpts[key]);
                }
                return arr;
            }, ['--id', id]);
            const childRes = yield (0, shell_1.spawn)('catalyst', ['iac:status', 'import', ...optsArr], {
                shell: true,
                stdio: ['inherit', 'inherit', 'inherit', 'ipc'],
                env: { PARENT_COMMAND: 'codedeck', GIT_URL: gitUrl }
            })
                .ASYNC()
                .catch((err) => (0, logger_1.debug)(err));
            return (childRes === null || childRes === void 0 ? void 0 : childRes.message) === 'success';
        }
        catch (err) {
            return false;
        }
    });
}
exports.listenDeploy = listenDeploy;
function getTemplateFile(deckZip) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const archiver = new archiver_1.default();
            archiver.load(deckZip);
            return archiver.readFile(/project-template-[\.0-9]+\.json/);
        }
        catch (err) {
            throw new error_1.default('Invalid ZIP file', { exit: 1, original: err });
        }
    });
}
exports.getTemplateFile = getTemplateFile;
function getDeckFromGit() {
    return __awaiter(this, void 0, void 0, function* () {
        const deckAPI = yield (0, endpoints_1.codeDeck)();
        const deckJson = yield deckAPI.data();
        const transformedDeck = Object.values(deckJson).reduce((deck, rawDeck) => {
            const deckCategory = deck[rawDeck.category];
            if (deckCategory === undefined) {
                deck[rawDeck.category] = [
                    {
                        display: rawDeck.title,
                        value: rawDeck,
                        short: rawDeck.title,
                        expand: 'Description: ' + rawDeck.description.short
                    }
                ];
            }
            else {
                deck[rawDeck.category].push({
                    display: rawDeck.title,
                    value: rawDeck,
                    short: rawDeck.title,
                    expand: 'Description: ' + rawDeck.description.short
                });
            }
            return deck;
        }, {});
        const choices = Object.entries(transformedDeck).map(([category, deck]) => {
            const treeNode = new tree_1.TreeNode('Category: ' + category);
            deck.forEach((de) => treeNode.addNode(de));
            return treeNode;
        });
        yield prompt_1.default.register('tree');
        const deck = yield prompt_1.default.ask(prompt_1.default.question('code', 'Select the code library that you want to install', {
            type: 'tree',
            treeChoices: choices
        }));
        return deck.code;
    });
}
exports.getDeckFromGit = getDeckFromGit;
class CodeDeckToken {
    static createToken(importId, gitUrl) {
        const tokenObj = [importId, gitUrl];
        const tokenString = JSON.stringify(tokenObj);
        return Buffer.from(tokenString).toString('base64');
    }
    static getDetailsFromToken(token) {
        const decodedString = Buffer.from(token, 'base64').toString();
        return JSON.parse(decodedString);
    }
}
exports.CodeDeckToken = CodeDeckToken;
