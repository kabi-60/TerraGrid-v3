'use strict';
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _a, _PortResolver_takenPorts, _PortResolver_isPortTaken;
Object.defineProperty(exports, "__esModule", { value: true });
const ansi_colors_1 = require("ansi-colors");
const portfinder_1 = require("portfinder");
const error_1 = __importDefault(require("./error"));
const runtime_store_1 = __importDefault(require("./runtime-store"));
const constants_1 = require("./util_modules/constants");
const logger_1 = require("./util_modules/logger");
const featureRef = {
    client: 'client',
    aio: 'advancedio',
    bio: 'basicio',
    master: 'master',
    appsail: 'appsail',
    browserlogic: 'browser_logic'
};
class PortResolver {
    static getFreePort(startPort, searchSpan, dupCheck) {
        return __awaiter(this, void 0, void 0, function* () {
            if (searchSpan < 0) {
                throw new Error('unable to find port. searchSpan has reached the bottom line');
            }
            const port = yield (0, portfinder_1.getPortPromise)({
                port: startPort,
                stopPort: startPort + searchSpan
            });
            if (__classPrivateFieldGet(PortResolver, _a, "m", _PortResolver_isPortTaken).call(PortResolver, port)) {
                if (dupCheck) {
                    return PortResolver.getFreePort(port + 1, searchSpan - (port - startPort), dupCheck);
                }
                return port;
            }
            __classPrivateFieldGet(PortResolver, _a, "f", _PortResolver_takenPorts).add(port);
            return port;
        });
    }
    static getPort(feature, type, { name = '', duplicateCheck = true, searchSpan = 20, fallbackNeeded = true, server } = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            let port = parseInt(runtime_store_1.default.get(`context.port.${type}.${feature}.${name}`), 10);
            port = isNaN(port) ? parseInt(runtime_store_1.default.get(`context.port.${type}.${feature}`), 10) : port;
            if (isNaN(port)) {
                if (type === 'debug' && feature === 'client') {
                    throw new error_1.default('client cannot be debugged', { exit: 2 });
                }
                if (!fallbackNeeded) {
                    return -1;
                }
                if (feature === 'appsail') {
                    if (!server || type !== 'http') {
                        throw new error_1.default('Invalid appsail details', { exit: 2 });
                    }
                    port = constants_1.DEFAULT.serve_port['http']['appsail'][server];
                }
                else {
                    port = constants_1.DEFAULT.serve_port[type][featureRef[feature]];
                }
            }
            else {
                searchSpan = 0;
            }
            if (port === -1) {
                throw new error_1.default('port resolved to -1 for feature ' + feature + ' and type ' + type, {
                    exit: 2
                });
            }
            let finalPort = port;
            try {
                finalPort = yield PortResolver.getFreePort(port, searchSpan, duplicateCheck);
            }
            catch (e) {
                if (searchSpan === 0) {
                    const err = error_1.default.getErrorInstance(e, {
                        message: `Provided port '${port}' is not available`,
                        skipHelp: false,
                        fileName: __filename
                    });
                    err.errorId = 'PORT-RESOLVER-1';
                    err.arg = [
                        ansi_colors_1.bold.red(port + ''),
                        type === 'debug' ? 'debugging' : 'serving',
                        (0, ansi_colors_1.bold)(feature),
                        name,
                        type
                    ];
                    throw err;
                }
                const cerr = error_1.default.getErrorInstance(e, {
                    message: `No ports from '${port}' to ${port + searchSpan} is free to use as a ${type} port.`,
                    skipHelp: server ? true : false,
                    fileName: __filename
                });
                cerr.errorId = 'PORT-RESOLVER-2';
                cerr.arg = [(0, ansi_colors_1.bold)(port + ''), (0, ansi_colors_1.bold)(port + searchSpan + ''), (0, ansi_colors_1.bold)('--' + type)];
                throw cerr;
            }
            if (finalPort !== port) {
                (0, logger_1.debug)(`${type} port : '${port}' is not available. Hence port '${finalPort}' will be used instead.`);
            }
            return finalPort;
        });
    }
}
exports.default = PortResolver;
_a = PortResolver, _PortResolver_isPortTaken = function _PortResolver_isPortTaken(port) {
    return __classPrivateFieldGet(PortResolver, _a, "f", _PortResolver_takenPorts).has(port);
};
_PortResolver_takenPorts = { value: new Set() };
