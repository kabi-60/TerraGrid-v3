'use strict';
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = require("path");
const semver_1 = require("semver");
const util_1 = require("util");
const error_1 = __importDefault(require("../error"));
const config_store_1 = __importDefault(require("../config-store"));
const rc_1 = __importDefault(require("../internal/rc"));
const fs_1 = require("../util_modules/fs");
const logger_1 = require("../util_modules/logger");
const runMigration = (rc, migFiles, idx = 0) => __awaiter(void 0, void 0, void 0, function* () {
    if (migFiles.length <= idx) {
        return Promise.resolve();
    }
    const migFile = migFiles[idx];
    const currentMigFileVersion = (0, path_1.parse)(migFile).name;
    const migDetails = rc.get(['migration', currentMigFileVersion]);
    if (migDetails && migDetails.completed) {
        return runMigration(rc, migFiles, ++idx);
    }
    try {
        const migModule = yield Promise.resolve().then(() => __importStar(require(migFile)));
        if (migModule.isRequire()) {
            (0, logger_1.debug)('migration started for v' + currentMigFileVersion);
            migModule.migrate();
        }
    }
    catch (e) {
        (0, logger_1.debug)('migration failed for v' + currentMigFileVersion);
        rc.set(['migration', currentMigFileVersion], {
            error: (0, util_1.inspect)(e),
            completed: false
        });
        rc.syncSave();
        const err = error_1.default.getErrorInstance(e, {
            message: 'Unable to run migration file ' + migFile,
            skipHelp: false
        });
        err.exit = 2;
        throw err;
    }
    rc.set(['migration', currentMigFileVersion], {
        completed: true
    });
    rc.set('migration.last_success', currentMigFileVersion);
    rc.syncSave();
    (0, logger_1.debug)('migration completed for v' + currentMigFileVersion);
    return runMigration(rc, migFiles, ++idx);
});
const runGlobalMigration = (migFiles) => __awaiter(void 0, void 0, void 0, function* () {
    if (migFiles.length === 0) {
        return;
    }
    const migFile = migFiles.shift();
    if (!migFile) {
        return;
    }
    const currentMigFileVersion = (0, path_1.parse)(migFile).name;
    const migDetails = config_store_1.default.get('migration.' + currentMigFileVersion.replace(new RegExp('\\.', 'g'), '\\.'));
    if (migDetails && migDetails.completed) {
        return runGlobalMigration(migFiles);
    }
    try {
        const migModule = yield Promise.resolve().then(() => __importStar(require(migFile)));
        if (migModule.isRequire()) {
            (0, logger_1.debug)('migration started for v' + currentMigFileVersion);
            migModule.migrate();
        }
    }
    catch (e) {
        (0, logger_1.debug)('migration failed for v' + currentMigFileVersion);
        config_store_1.default.set('migration.' + currentMigFileVersion.replace(new RegExp('\\.', 'g'), '\\.'), {
            error: (0, util_1.inspect)(e),
            completed: false
        });
        const err = error_1.default.getErrorInstance(e, {
            message: 'Unable to run migration file ' + migFile,
            skipHelp: false
        });
        err.exit = 2;
        throw err;
    }
    config_store_1.default.set('migration.' + currentMigFileVersion.replace(new RegExp('\\.', 'g'), '\\.'), {
        completed: true
    });
    config_store_1.default.set('migration.last_success', currentMigFileVersion);
    (0, logger_1.debug)('migration completed for v' + currentMigFileVersion);
    return runGlobalMigration(migFiles);
});
const getMigFiles = (dir, currentVersion, lastRunVersion) => {
    const dirExists = fs_1.SYNC.dirExists(dir);
    if (!dirExists) {
        return [];
    }
    const migFiles = fs_1.SYNC.getAllFiles(dir);
    if (migFiles.length === 0) {
        return [];
    }
    if (lastRunVersion && (0, semver_1.gte)(lastRunVersion, currentVersion)) {
        return [];
    }
    return migFiles
        .filter((file) => (0, semver_1.valid)((0, path_1.parse)(file).name) &&
        (!lastRunVersion || (0, semver_1.gte)((0, path_1.parse)(file).name, lastRunVersion)))
        .sort((v1, v2) => (0, semver_1.compare)((0, path_1.parse)(v1).name, (0, path_1.parse)(v2).name));
};
exports.default = (currentVersion) => __awaiter(void 0, void 0, void 0, function* () {
    const promiseArr = [];
    const lastRunGlobalMigration = config_store_1.default.get('migration.last_success');
    const globalMigFiles = getMigFiles((0, path_1.join)(__dirname, 'global'), currentVersion, lastRunGlobalMigration);
    if (globalMigFiles.length > 0) {
        promiseArr.push(runGlobalMigration(globalMigFiles));
    }
    const rc = yield rc_1.default.load().catch(() => (0, logger_1.debug)('Unable to load rc file.'));
    if (rc && rc.loaded) {
        const lastRunLocalMigration = rc.get('migration.last_success');
        const localMigFiles = getMigFiles((0, path_1.join)(__dirname, 'local'), currentVersion, lastRunLocalMigration);
        if (localMigFiles.length > 0) {
            promiseArr.push(runMigration(rc, localMigFiles));
        }
    }
    return Promise.all(promiseArr);
});
