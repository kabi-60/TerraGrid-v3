'use strict';
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ansi_colors_1 = require("ansi-colors");
const pretty_ms_1 = __importDefault(require("pretty-ms"));
const throbber_1 = __importDefault(require("./throbber"));
class Progress {
    constructor({ title = '', fillChar = 'Â·', bgChar = ' ', startingChar = '[', endingChar = ']', total = 10, failure, progressType = 'download' } = {}) {
        this.title = title;
        this.fillChar = fillChar;
        this.bgChar = bgChar;
        this.startingChar = startingChar;
        this.endingChar = endingChar;
        this.total = total;
        this.throbber = throbber_1.default.getInstance();
        this.startTime = process.hrtime();
        this.currentProgress = 0;
        this.currentProgressFrame = '';
        this.failure = failure;
        this.progressType = progressType;
    }
    get MAX_SCREEN_LENGTH() {
        return 35;
    }
    get barLength() {
        return this.total > this.MAX_SCREEN_LENGTH ? this.MAX_SCREEN_LENGTH : this.total;
    }
    getCompleteness(progress) {
        return Math.round((this.barLength * progress) / this.total);
    }
    fillProgress() {
        return this.fillChar.repeat(this.getCompleteness(this.currentProgress));
    }
    fillSpace() {
        return this.bgChar.repeat(this.barLength - this.getCompleteness(this.currentProgress));
    }
    updateProgress(text) {
        this.throbber.update(this.title, { text });
    }
    error(err) {
        const msg = this.failure ? this.failure(err) : typeof err === 'string' ? err : err === null || err === void 0 ? void 0 : err.message;
        msg ? this.throbber.fail(this.title, { text: msg }) : this.throbber.remove(this.title);
    }
    tick(count = 1) {
        let prependedHeader = '';
        if (this.currentProgress === 0) {
            this.throbber.add(this.title);
        }
        this.currentProgress += count;
        const [seconds, nanoSeconds] = process.hrtime(this.startTime);
        const timeSinceStartInMs = seconds * 1000 + nanoSeconds / 1e6;
        const averageTimePerCount = timeSinceStartInMs / this.currentProgress;
        const estTimeLeftStr = (0, pretty_ms_1.default)(Math.round(averageTimePerCount * (this.total - this.currentProgress)));
        prependedHeader = 'Est. time left: ' + `${(0, ansi_colors_1.white)(estTimeLeftStr)}`;
        if (this.currentProgress >= this.total) {
            if (this.throbber.hasActiveSpinners()) {
                const [totalSec] = process.hrtime(this.startTime);
                this.throbber.succeed(this.title, {
                    text: `${this.title} ${this.progressType}ed in ${totalSec} seconds`
                });
            }
            return;
        }
        this.currentProgressFrame =
            `${this.title} ${this.startingChar}${this.fillProgress()}${this.fillSpace()}${this.endingChar} \n` +
                `${prependedHeader ? `${prependedHeader}\n` : ''}`;
        this.updateProgress(this.currentProgressFrame);
    }
}
exports.default = Progress;
