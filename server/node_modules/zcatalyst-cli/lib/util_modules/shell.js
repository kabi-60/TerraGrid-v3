'use strict';
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.which = exports.spawn = exports.supportsUnicode = exports.clearLine = exports.clearStdout = void 0;
const child_process_1 = require("child_process");
const cross_spawn_1 = __importDefault(require("cross-spawn"));
const path_1 = __importDefault(require("path"));
const readline_1 = __importDefault(require("readline"));
const env_1 = require("./env");
const logger_1 = require("./logger");
function clearStdout(fullClear = false) {
    if (fullClear === true) {
        process.stdout.write('\x1b[2J');
    }
    process.stdout.write('\x1b[0f');
}
exports.clearStdout = clearStdout;
function clearLine(stream = process.stdout) {
    readline_1.default.cursorTo(stream, 0);
    readline_1.default.clearLine(stream, 0);
}
exports.clearLine = clearLine;
function supportsUnicode() {
    return (process.platform !== 'win32' ||
        process.env.TERM_PROGRAM === 'vscode' ||
        !!process.env.WT_SESSION);
}
exports.supportsUnicode = supportsUnicode;
function spawn(command, opts, _a = {}) {
    var { cwd = process.cwd(), stdio = 'inherit', shell = false } = _a, otherOpts = __rest(_a, ["cwd", "stdio", "shell"]);
    otherOpts.env = Object.assign(Object.assign(Object.assign({}, process.env), (otherOpts.env || {})), { CATALYST_SUB_PROCESS: 'true' });
    return {
        SYNC: () => cross_spawn_1.default.sync(command, opts, Object.assign({ cwd, stdio, shell }, otherOpts)),
        ASYNC: () => {
            const childProcess = (0, cross_spawn_1.default)(command, opts, Object.assign({ cwd,
                stdio,
                shell }, otherOpts));
            return new Promise((res, rej) => {
                var _a;
                let message = '';
                let stdout = '';
                (_a = childProcess.stdout) === null || _a === void 0 ? void 0 : _a.on('data', (msg) => {
                    stdout += msg.toString();
                });
                childProcess.on('message', (msg) => {
                    message += msg.toString();
                });
                childProcess.on('error', (err) => rej(err));
                childProcess.on('exit', (code) => {
                    if (code !== 0) {
                        rej(code);
                    }
                    res({ message, stdout });
                });
            });
        },
        RAW: () => {
            const child = (0, cross_spawn_1.default)(command, opts, Object.assign({ cwd, stdio, shell }, otherOpts)).on('error', logger_1.debug);
            return child;
        }
    };
}
exports.spawn = spawn;
function which(commandName, { alwaysResolve = true }) {
    let cleanedCmd = commandName;
    if (env_1.isWindows) {
        const isPathName = /[\\]/.test(commandName);
        if (isPathName) {
            const dirname = '"' + path_1.default.dirname(commandName) + '"';
            const basename = '"' + path_1.default.basename(commandName) + '"';
            cleanedCmd = dirname + ':' + basename;
        }
        else {
            cleanedCmd = '"' + commandName + '"';
        }
    }
    else if (/[^A-Za-z0-9_/:=-]/.test(commandName)) {
        cleanedCmd = "'" + commandName.replace(/'/g, "'\\''") + "'";
        cleanedCmd = cleanedCmd
            .replace(/^(?:'')+/g, '')
            .replace(/\\'''/g, "\\'");
    }
    return new Promise((resolve, reject) => {
        if (env_1.isWindows) {
            if (/[\x00-\x1f<>:"|?*]/.test(commandName)) {
                alwaysResolve ? resolve(false) : reject('controll char test failed');
            }
            (0, child_process_1.exec)('where ' + cleanedCmd, (error) => {
                if (error !== null) {
                    alwaysResolve ? resolve(false) : reject(error);
                }
                else {
                    resolve(true);
                }
            });
        }
        else {
            (0, child_process_1.exec)('command -v ' +
                cleanedCmd +
                ' 2>/dev/null' +
                ' && { echo >&1 ' +
                cleanedCmd +
                '; exit 0; }', (error, stdout, stderr) => {
                if (stdout) {
                    resolve(true);
                }
                else {
                    alwaysResolve ? resolve(false) : reject(error || stderr);
                }
            });
        }
    });
}
exports.which = which;
