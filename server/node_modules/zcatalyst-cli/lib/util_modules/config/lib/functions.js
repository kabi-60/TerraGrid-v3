'use strict';
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.plugin = exports.script = exports.targets = exports.ignore = exports.source = exports.raw = void 0;
const path_1 = require("path");
const error_1 = __importDefault(require("../../../error"));
const runtime_store_1 = __importDefault(require("../../../runtime-store"));
const constants_1 = require("../../constants");
const js_1 = require("../../js");
function getRawTargets() {
    const functionConfig = raw();
    if (functionConfig && (functionConfig === null || functionConfig === void 0 ? void 0 : functionConfig.targets)) {
        return functionConfig === null || functionConfig === void 0 ? void 0 : functionConfig.targets;
    }
    return [];
}
function getMatchingTarget(sourcePath) {
    const rawTargetArr = getRawTargets();
    const matchTargets = rawTargetArr.filter((target) => {
        if (typeof target === 'string') {
            return false;
        }
        if (target.source) {
            return sourcePath.endsWith(target.source);
        }
        return false;
    });
    if (matchTargets.length > 0) {
        return matchTargets[0];
    }
    return;
}
function raw(throwError = false) {
    const config = runtime_store_1.default.get('config', null);
    if (config === null) {
        if (throwError) {
            throw new error_1.default(constants_1.FILENAME.config + ' file is required', { exit: 2 });
        }
        return;
    }
    return config.get('functions');
}
exports.raw = raw;
function source(fallback = constants_1.FOLDERNAME.functions) {
    const functionsConfig = raw();
    if (functionsConfig === undefined || functionsConfig.source === undefined) {
        return fallback;
    }
    return functionsConfig.source;
}
exports.source = source;
function ignore(sourcePath) {
    let matchTarget;
    if (sourcePath) {
        matchTarget = getMatchingTarget(sourcePath);
    }
    let ignoreArr = [];
    if (matchTarget && matchTarget.ignore) {
        ignoreArr = matchTarget.ignore;
    }
    else {
        const functionConfig = raw();
        ignoreArr = (functionConfig && functionConfig.ignore) || [];
    }
    return ignoreArr.map((value) => {
        if (js_1.JS.indexOf(value, path_1.sep) === js_1.JS.size(value) - 1) {
            return '**' + path_1.sep + js_1.JS.initial(value).join('');
        }
        else {
            if (js_1.JS.startsWith(value, path_1.sep)) {
                return js_1.JS.endsWith(value, path_1.sep)
                    ? sourcePath + js_1.JS.initial(value).join('')
                    : sourcePath + value;
            }
            return js_1.JS.endsWith(value, path_1.sep)
                ? sourcePath + path_1.sep + js_1.JS.initial(value).join('')
                : sourcePath + path_1.sep + value;
        }
    });
}
exports.ignore = ignore;
function targets(fallback) {
    const rawTargetArr = getRawTargets();
    if (rawTargetArr === null) {
        if (fallback === undefined) {
            throw new error_1.default('Function targets array is empty.', { exit: 2 });
        }
        return fallback;
    }
    return rawTargetArr.map((targetVal) => {
        if (typeof targetVal === 'string') {
            return targetVal;
        }
        if (typeof targetVal.source === 'string') {
            return targetVal.source;
        }
        throw new error_1.default('Function target array is corrupted.', { exit: 2 });
    });
}
exports.targets = targets;
function script(name, fallback, sourcePath) {
    let matchTarget;
    if (sourcePath) {
        matchTarget = getMatchingTarget(sourcePath);
    }
    let rawScripts;
    if (matchTarget && matchTarget.scripts) {
        rawScripts = matchTarget.scripts;
    }
    else {
        const functionConfig = raw();
        rawScripts = functionConfig && (functionConfig === null || functionConfig === void 0 ? void 0 : functionConfig.scripts);
    }
    if (rawScripts === undefined && fallback === undefined) {
        throw new error_1.default('Scripts not found', { exit: 2 });
    }
    if (name === undefined) {
        return rawScripts || fallback;
    }
    if (rawScripts && rawScripts[name] === undefined && fallback === undefined) {
        throw new error_1.default('Scripts not found', { exit: 2 });
    }
    return (rawScripts && rawScripts[name]) || fallback;
}
exports.script = script;
function plugin(name, sourcePath) {
    let matchTarget;
    if (sourcePath) {
        matchTarget = getMatchingTarget(sourcePath);
    }
    let rawPlugins;
    if (matchTarget && matchTarget.plugin) {
        rawPlugins = matchTarget.plugin;
    }
    else {
        const functionConfig = raw();
        rawPlugins = functionConfig && functionConfig.plugin;
    }
    if (!rawPlugins) {
        return;
    }
    if (typeof rawPlugins === 'string') {
        if (name === undefined) {
            return {
                validate: rawPlugins,
                start: rawPlugins,
                build: rawPlugins
            };
        }
        return rawPlugins;
    }
    if (name === undefined) {
        return rawPlugins;
    }
    return rawPlugins && rawPlugins[name];
}
exports.plugin = plugin;
