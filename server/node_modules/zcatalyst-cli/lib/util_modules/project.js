'use strict';
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveProjectPath = exports.upsertProject = exports.upsertEnv = exports.removeProject = exports.transformEnv = exports.transformProject = exports.makeDefaultProjectActive = exports.getProjectRoot = exports.getDefaultEnvName = exports.getDefaultProjectName = exports.getDefaultProjectId = exports.getProjectTimezone = exports.getDomainKey = exports.getDomainPrefix = exports.getEnvName = exports.getEnvId = exports.getProjectName = exports.getProjectId = void 0;
const ansi_colors_1 = require("ansi-colors");
const path_1 = __importDefault(require("path"));
const error_1 = __importDefault(require("../error"));
const runtime_store_1 = __importDefault(require("../runtime-store"));
const constants_1 = require("./constants");
const fs_1 = require("./fs");
const js_1 = require("./js");
function getDefaultProject(throwError) {
    const rc = runtime_store_1.default.get('rc', null);
    if (rc === null) {
        if (throwError) {
            throw new error_1.default(constants_1.FILENAME.rc + ' file needed', {
                exit: 1,
                errorId: 'PROJ-1',
                arg: [constants_1.FILENAME.rc, (0, ansi_colors_1.bold)('catalyst init project')]
            });
        }
        return;
    }
    return rc.defaultProject;
}
function getDefaultEnv(throwError) {
    const rc = runtime_store_1.default.get('rc', null);
    if (rc === null) {
        if (throwError) {
            throw new error_1.default(constants_1.FILENAME.rc + ' file needed', {
                exit: 1,
                errorId: 'PROJ-1',
                arg: [constants_1.FILENAME.rc, (0, ansi_colors_1.bold)('catalyst init project')]
            });
        }
        return;
    }
    return rc.defaultEnv;
}
function getProjectId(fallback) {
    const projectId = runtime_store_1.default.get('project.id', null);
    if (projectId === null) {
        if (fallback === undefined) {
            throw new error_1.default('ProjectId is needed', {
                exit: 1,
                errorId: 'PROJ-2',
                arg: ['Project ID', (0, ansi_colors_1.bold)('catalyst init project --force')]
            });
        }
        return fallback;
    }
    return projectId;
}
exports.getProjectId = getProjectId;
function getProjectName(fallback) {
    const projectName = runtime_store_1.default.get('project.name', null);
    if (projectName === null) {
        if (fallback === undefined) {
            throw new error_1.default('ProjectName is needed', {
                exit: 1,
                errorId: 'PROJ-2',
                arg: ['Project Name', (0, ansi_colors_1.bold)('catalyst init project --force')]
            });
        }
        return fallback;
    }
    return projectName + '';
}
exports.getProjectName = getProjectName;
function getEnvId(fallback) {
    return runtime_store_1.default.get('project.env.id', fallback);
}
exports.getEnvId = getEnvId;
function getEnvName(fallback = 'Development') {
    return runtime_store_1.default.get('project.env.name', fallback);
}
exports.getEnvName = getEnvName;
function getDomainPrefix(fallback) {
    const domainName = runtime_store_1.default.get('project.domain.name', null);
    if (domainName === null) {
        if (fallback === undefined) {
            throw new error_1.default('domainName is needed', {
                exit: 1,
                errorId: 'PROJ-2',
                arg: ['Domain Name', (0, ansi_colors_1.bold)('catalyst init project --force')]
            });
        }
        return fallback;
    }
    return domainName + '';
}
exports.getDomainPrefix = getDomainPrefix;
function getDomainKey(fallback) {
    const domainId = runtime_store_1.default.get('project.domain.id', null);
    if (domainId === null) {
        if (fallback === undefined) {
            throw new error_1.default('domainId is needed', {
                exit: 1,
                errorId: 'PROJ-2',
                arg: ['Domain ID', (0, ansi_colors_1.bold)('catalyst init project --force')]
            });
        }
        return fallback;
    }
    return domainId;
}
exports.getDomainKey = getDomainKey;
function getProjectTimezone(fallback) {
    const projectTimezone = runtime_store_1.default.get('project.timezone', null);
    if (projectTimezone === null) {
        if (fallback === undefined) {
            throw new error_1.default('Project timezone is needed', {
                exit: 1,
                errorId: 'PROJ-2',
                arg: ['Project timezone', (0, ansi_colors_1.bold)('catalyst init project --force')]
            });
        }
        return fallback;
    }
    return projectTimezone + '';
}
exports.getProjectTimezone = getProjectTimezone;
function getDefaultProjectId(fallback) {
    const defaultProject = getDefaultProject(fallback === undefined);
    if (defaultProject !== undefined) {
        return defaultProject.id + '';
    }
    if (fallback === undefined) {
        throw new error_1.default('Default project id in rc file is not found', {
            exit: 2
        });
    }
    return fallback;
}
exports.getDefaultProjectId = getDefaultProjectId;
function getDefaultProjectName(fallback) {
    const defaultProject = getDefaultProject(fallback === undefined);
    if (defaultProject !== undefined) {
        return defaultProject.name;
    }
    if (fallback === undefined) {
        throw new error_1.default('Default project name in rc file is not found', {
            exit: 2
        });
    }
    return fallback;
}
exports.getDefaultProjectName = getDefaultProjectName;
function getDefaultEnvName(fallback) {
    const defaultEnv = getDefaultEnv(fallback === undefined);
    if (defaultEnv !== undefined) {
        return defaultEnv.name;
    }
    if (fallback === undefined) {
        throw new error_1.default('Default Environment name in rc file is not found', {
            exit: 2
        });
    }
    return fallback;
}
exports.getDefaultEnvName = getDefaultEnvName;
function getProjectRoot(fallback = process.cwd()) {
    let projectRootDir = process.cwd();
    while (!fs_1.SYNC.fileExists(path_1.default.resolve(projectRootDir, './' + constants_1.FILENAME.config))) {
        const parentDir = path_1.default.dirname(projectRootDir);
        if (parentDir === projectRootDir) {
            return fallback;
        }
        projectRootDir = parentDir;
    }
    return projectRootDir;
}
exports.getProjectRoot = getProjectRoot;
function makeDefaultProjectActive() {
    return __awaiter(this, void 0, void 0, function* () {
        const defaultProject = getDefaultProject(false);
        if (defaultProject === undefined) {
            throw new error_1.default('Unable to set default project active since value is not defined', {
                exit: 2
            });
        }
        const defaultEnv = getDefaultEnv(false);
        if (defaultEnv === undefined) {
            throw new error_1.default('Unable to set default env active since value is not defined', {
                exit: 2
            });
        }
        yield upsertProject(defaultProject, { active: true });
        return upsertEnv(defaultProject.id, defaultEnv, { active: true });
    });
}
exports.makeDefaultProjectActive = makeDefaultProjectActive;
function transformProject(projectObj) {
    return js_1.JS.transform(projectObj, (result, value, key) => {
        switch (key) {
            case 'project_id':
            case 'id':
                key = 'id';
                break;
            case 'project_name':
                key = 'name';
                break;
            case 'project_domain_details':
                key = 'domain';
                value = {
                    id: value.project_domain_id,
                    name: value.project_domain_name
                };
                break;
            case 'project_type':
                key = 'type';
                break;
            default:
                break;
        }
        js_1.JS.set(result, key, value);
    }, {});
}
exports.transformProject = transformProject;
function transformEnv(envObj) {
    return js_1.JS.transform(envObj, (result, value, key) => {
        switch (key) {
            case 'env_zgid':
                key = 'id';
                break;
            case 'env_name':
                key = 'name';
                break;
            case 'env_type':
                key = 'type';
                break;
            default:
                break;
        }
        js_1.JS.set(result, key, value);
    }, {});
}
exports.transformEnv = transformEnv;
function removeProject(projectId) {
    return __awaiter(this, void 0, void 0, function* () {
        const rc = runtime_store_1.default.get('rc', null);
        if (rc === null) {
            throw new error_1.default(constants_1.FILENAME.rc + ' file needed to remove project', {
                exit: 2
            });
        }
        return rc.removeProject(projectId);
    });
}
exports.removeProject = removeProject;
function upsertEnv(projectId, envObj, { base = false, active = false }) {
    return __awaiter(this, void 0, void 0, function* () {
        const transformedEnv = transformEnv(envObj);
        const rc = runtime_store_1.default.get('rc', null);
        if (rc === null) {
            throw new error_1.default(constants_1.FILENAME.rc + ' file needed to upsert environment', {
                exit: 2
            });
        }
        return rc.associateEnv(projectId, transformedEnv, {
            base,
            active
        });
    });
}
exports.upsertEnv = upsertEnv;
function upsertProject(projectObj, { base = false, active = false }) {
    return __awaiter(this, void 0, void 0, function* () {
        const transformedProj = transformProject(projectObj);
        const rc = runtime_store_1.default.get('rc', null);
        if (rc === null) {
            throw new error_1.default(constants_1.FILENAME.rc + ' file needed to upsert project', {
                exit: 2
            });
        }
        return rc.upsertProject(transformedProj, {
            base,
            active
        });
    });
}
exports.upsertProject = upsertProject;
function resolveProjectPath(...filePath) {
    let root = runtime_store_1.default.get('project.root', runtime_store_1.default.get('cwd'));
    root = root !== undefined ? root : getProjectRoot();
    return path_1.default.normalize(path_1.default.resolve(root, ...filePath));
}
exports.resolveProjectPath = resolveProjectPath;
