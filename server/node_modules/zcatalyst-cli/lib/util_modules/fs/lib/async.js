'use strict';
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.chmod = exports.writeJSONFile = exports.readJSONFile = exports.emptyDir = exports.findAndReplace = exports.rename = exports.copyDir = exports.copyFiles = exports.copyFile = exports.deleteDir = exports.deleteFile = exports.ensureDir = exports.ensureFile = exports.walk = exports.dirList = exports.writeFile = exports.tempFile = exports.readFile = exports.fileExists = exports.dirExists = exports.isPathExists = void 0;
const fs_extra_1 = __importDefault(require("fs-extra"));
const minimatch_1 = __importDefault(require("minimatch"));
const os_1 = __importDefault(require("os"));
const path_1 = __importDefault(require("path"));
const utils_js_1 = require("../utils.js");
function isPathExists(path) {
    return __awaiter(this, void 0, void 0, function* () {
        const stats = yield fs_extra_1.default.stat((0, utils_js_1.untildify)(path)).catch(() => false);
        return stats && true;
    });
}
exports.isPathExists = isPathExists;
function dirExists(pth) {
    return __awaiter(this, void 0, void 0, function* () {
        const stats = yield fs_extra_1.default.stat((0, utils_js_1.untildify)(pth)).catch(() => false);
        return stats && stats.isDirectory();
    });
}
exports.dirExists = dirExists;
function fileExists(pth) {
    return __awaiter(this, void 0, void 0, function* () {
        const stats = yield fs_extra_1.default.stat((0, utils_js_1.untildify)(pth)).catch(() => false);
        return stats && stats.isFile();
    });
}
exports.fileExists = fileExists;
function readFile(pth, type) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!(yield fileExists(pth))) {
            return undefined;
        }
        return (type === 'buffer'
            ? fs_extra_1.default.readFile(pth)
            : type
                ? fs_extra_1.default.readFile(pth, type)
                : fs_extra_1.default.readFile(pth, 'utf8'));
    });
}
exports.readFile = readFile;
function tempFile(name = Date.now().toString(), content) {
    return __awaiter(this, void 0, void 0, function* () {
        const tempDir = path_1.default.join(os_1.default.tmpdir(), '.catalyst');
        const tempFilePth = path_1.default.join(tempDir, name);
        content === undefined ? yield ensureFile(tempFilePth) : yield writeFile(tempFilePth, content);
        return tempFilePth;
    });
}
exports.tempFile = tempFile;
function writeFile(pth, content, encoding = 'utf8') {
    return __awaiter(this, void 0, void 0, function* () {
        return fs_extra_1.default.writeFile(pth, content, { encoding });
    });
}
exports.writeFile = writeFile;
function dirList(dir) {
    return __awaiter(this, void 0, void 0, function* () {
        const files = yield fs_extra_1.default.readdir(dir);
        const entries = yield Promise.all(files.map((entity) => __awaiter(this, void 0, void 0, function* () {
            const entityPath = path_1.default.join(dir, entity);
            const stats = yield fs_extra_1.default.stat(entityPath);
            if (stats.isDirectory()) {
                return entityPath;
            }
            return undefined;
        })));
        return entries.filter((entry) => entry !== undefined);
    });
}
exports.dirList = dirList;
function walk(dir, { filter = {
    exclude: [],
    excludeDir: true
}, depth = -1, includeDirPaths = false } = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        const stats = yield fs_extra_1.default.lstat(dir);
        if (depth === 0) {
            return includeDirPaths ? [{ path: dir, stats }] : [];
        }
        const isDir = stats.isDirectory() && !stats.isSymbolicLink();
        const files = isDir ? yield fs_extra_1.default.readdir(dir) : [path_1.default.basename(dir)];
        const folderContentPromise = files.map((entry) => __awaiter(this, void 0, void 0, function* () {
            const entryPath = isDir ? path_1.default.join(dir, entry) : dir;
            const entryPathStats = yield fs_extra_1.default.lstat(entryPath);
            const isEntryPthDir = entryPathStats.isDirectory() && !entryPathStats.isSymbolicLink();
            let excludeMatch = false;
            if (!(isEntryPthDir && !filter.excludeDir)) {
                for (const glob of filter.exclude || []) {
                    excludeMatch = excludeMatch || (0, minimatch_1.default)(entryPath, glob);
                }
            }
            if (excludeMatch) {
                return [];
            }
            return isEntryPthDir && depth !== 0
                ? walk(entryPath, { filter, depth: depth - 1, includeDirPaths })
                : [{ path: entryPath, stats: entryPathStats }];
        }));
        const folderContents = yield Promise.all(folderContentPromise);
        return folderContents.reduce((all, folderContent) => all.concat(folderContent), includeDirPaths ? [{ path: dir, stats }] : []);
    });
}
exports.walk = walk;
function ensureFile(filePath, cleanFile = false) {
    return __awaiter(this, void 0, void 0, function* () {
        const isFile = yield fileExists(filePath);
        if (!isFile) {
            return fs_extra_1.default.ensureFile(filePath);
        }
        if (cleanFile) {
            return fs_extra_1.default.truncate(filePath);
        }
        return;
    });
}
exports.ensureFile = ensureFile;
function ensureDir(pth) {
    return __awaiter(this, void 0, void 0, function* () {
        return fs_extra_1.default.ensureDir(pth);
    });
}
exports.ensureDir = ensureDir;
function deleteFile(filePath) {
    return __awaiter(this, void 0, void 0, function* () {
        return fs_extra_1.default.remove(filePath);
    });
}
exports.deleteFile = deleteFile;
function deleteDir(dir) {
    return __awaiter(this, void 0, void 0, function* () {
        return fs_extra_1.default.remove(dir);
    });
}
exports.deleteDir = deleteDir;
function copyFile(src, dest, flag) {
    return __awaiter(this, void 0, void 0, function* () {
        yield ensureDir(path_1.default.dirname(dest));
        return fs_extra_1.default.copyFile(src, dest, flag);
    });
}
exports.copyFile = copyFile;
function copyFiles(src, dest) {
    return __awaiter(this, void 0, void 0, function* () {
        return Promise.all(src.map((filePath) => {
            const file = path_1.default.basename(filePath);
            return copyFile(filePath, path_1.default.join(dest, file));
        }));
    });
}
exports.copyFiles = copyFiles;
function copyDir(srcDir, destDir, { filter = () => __awaiter(this, void 0, void 0, function* () { return true; }) } = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        return fs_extra_1.default.copy(srcDir, destDir, { filter });
    });
}
exports.copyDir = copyDir;
function rename(pth, modifier = (baseName) => baseName) {
    return __awaiter(this, void 0, void 0, function* () {
        if (Array.isArray(pth)) {
            yield Promise.all(pth.map((el) => rename(el, modifier)));
            return;
        }
        const parsedPath = path_1.default.parse(pth);
        const modifiedName = path_1.default.join(parsedPath.dir, modifier(parsedPath.base, parsedPath.ext));
        return fs_extra_1.default.rename(pth, modifiedName);
    });
}
exports.rename = rename;
const findAndReplace = (pth) => (templates, finalWords) => __awaiter(void 0, void 0, void 0, function* () {
    if (Array.isArray(pth)) {
        yield Promise.all(pth.map((el) => (0, exports.findAndReplace)(el)(templates, finalWords)));
        return;
    }
    const files = yield walk(pth);
    yield Promise.all(files.map((file) => __awaiter(void 0, void 0, void 0, function* () {
        let content = yield readFile(file.path);
        if (content === undefined) {
            return Promise.resolve();
        }
        if (Array.isArray(templates)) {
            templates.forEach((temp, i) => {
                content = content.replace(new RegExp(temp, 'g'), finalWords[i]);
            });
        }
        else {
            content = content.replace(new RegExp(templates, 'g'), finalWords);
        }
        return writeFile(file.path, content);
    })));
});
exports.findAndReplace = findAndReplace;
function emptyDir(dir) {
    return __awaiter(this, void 0, void 0, function* () {
        return fs_extra_1.default.emptyDir(dir);
    });
}
exports.emptyDir = emptyDir;
function readJSONFile(pth, opts) {
    return __awaiter(this, void 0, void 0, function* () {
        if (opts && opts.checkpath && !(yield fileExists(pth))) {
            return undefined;
        }
        return fs_extra_1.default.readJson(pth, opts);
    });
}
exports.readJSONFile = readJSONFile;
function writeJSONFile(pth, object, opts = { spaces: '\t' }) {
    return __awaiter(this, void 0, void 0, function* () {
        yield ensureFile(pth, true);
        return fs_extra_1.default.writeJson(pth, object, opts);
    });
}
exports.writeJSONFile = writeJSONFile;
function chmod(path, mode, { checkPath = true, recursive = false } = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        if (checkPath && !(yield isPathExists(path))) {
            return Promise.reject('Path does not exists');
        }
        if (recursive && (yield dirExists(path))) {
            const paths = yield walk(path, { includeDirPaths: true, depth: 1 });
            paths.shift();
            yield Promise.all(paths.map((_path) => chmod(_path.path, mode, { recursive, checkPath })));
        }
        return fs_extra_1.default.chmod(path, mode);
    });
}
exports.chmod = chmod;
