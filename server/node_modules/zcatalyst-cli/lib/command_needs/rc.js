'use strict';
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ansi_colors_1 = require("ansi-colors");
const endpoints_1 = require("../endpoints");
const error_1 = __importDefault(require("../error"));
const rc_1 = __importDefault(require("../internal/rc"));
const prompt_1 = __importDefault(require("../prompt"));
const runtime_store_1 = __importDefault(require("../runtime-store"));
const constants_1 = require("../util_modules/constants");
const project_1 = __importDefault(require("../util_modules/constants/project"));
const js_1 = require("../util_modules/js");
const logger_1 = require("../util_modules/logger");
const option_1 = require("../util_modules/option");
const project_2 = require("../util_modules/project");
const config_store_1 = __importDefault(require("../config-store"));
const dc_1 = require("../dc");
const env_1 = require("../util_modules/env");
exports.default = ({ optional = false, resolveOnNotFound = false, skipOrgCheck = true } = {}) => __awaiter(void 0, void 0, void 0, function* () {
    const globOrgOpt = (0, option_1.getGlobalOptionValue)('org', null);
    const orgOpt = globOrgOpt ? globOrgOpt : (0, env_1.getEnvVariable)('CATALYST_ORG', null);
    const globProjectOpt = (0, option_1.getGlobalOptionValue)('project', null);
    const projectOpt = globProjectOpt
        ? globProjectOpt
        : (0, env_1.getEnvVariable)('CATALYST_PROJECT', null);
    const orgApi = yield (0, endpoints_1.orgAPI)();
    if (orgOpt !== null) {
        const orgList = yield orgApi.getAllOrgs();
        const found = orgList.find((org) => org.id + '' === orgOpt);
        if (!found) {
            throw new error_1.default('Invalid "org" option supplied', {
                exit: 2
            });
        }
        runtime_store_1.default.set('project.env.id', orgOpt + '');
    }
    let projectApi = yield (0, endpoints_1.projectAPI)();
    let envApi = yield (0, endpoints_1.envAPI)();
    const convertProjectToProperties = (project) => {
        project = (0, project_2.transformProject)(project);
        runtime_store_1.default.set('project.name', project.name);
        runtime_store_1.default.set('project.id', project.id + '');
        runtime_store_1.default.set('project.domain', project.domain);
        runtime_store_1.default.set('project.timezone', project.timezone);
    };
    const convertEnvToProperties = (envArr) => {
        const envObj = js_1.JS.find(envArr, { env_name: constants_1.DEFAULT.env_name });
        if (envObj === undefined) {
            throw new error_1.default('Unable to find the development environment for this project', {
                exit: 2
            });
        }
        runtime_store_1.default.set('project.env', (0, project_2.transformEnv)(envObj));
    };
    let ignoreRC = false;
    if (projectOpt !== null) {
        if (parseInt(projectOpt, 10)) {
            const project = (yield projectApi.getProject(projectOpt));
            convertProjectToProperties(project);
            const envArr = (yield envApi.getEnvs(project.id + ''));
            convertEnvToProperties(envArr);
            ignoreRC = true;
        }
        else {
            const projectArr = (yield projectApi.getAllProjects());
            const project = js_1.JS.find(projectArr, { project_name: projectOpt });
            if (project === undefined) {
                const allOrgs = yield orgApi.getAllOrgs();
                const orgId = (0, project_2.getEnvId)();
                const orgDetails = allOrgs.find((org) => (!orgId && org.is_default) || org.name === orgId || org.id === orgId);
                throw new error_1.default('invalid project provided with the --project option', {
                    exit: 1,
                    errorId: 'RC-1',
                    arg: [
                        (0, ansi_colors_1.bold)(projectOpt),
                        (0, ansi_colors_1.bold)('--project'),
                        (0, ansi_colors_1.bold)(projectArr
                            .filter((proj) => proj.project_type &&
                            project_1.default.accepted_types.includes(proj.project_type))
                            .map((project) => '* ' + project.project_name)
                            .join('\n')),
                        `${orgDetails === null || orgDetails === void 0 ? void 0 : orgDetails.name}(${orgDetails === null || orgDetails === void 0 ? void 0 : orgDetails.id})` +
                            ((orgDetails === null || orgDetails === void 0 ? void 0 : orgDetails.is_default) ? ' [DEFAULT]' : '')
                    ]
                });
            }
            convertProjectToProperties(project);
            const envArr = (yield envApi.getEnvs(project.id + ''));
            convertEnvToProperties(envArr);
            ignoreRC = true;
        }
    }
    else {
        ignoreRC = false;
    }
    const rcInstance = yield rc_1.default.load().catch((err) => {
        if (optional || ignoreRC) {
            (0, logger_1.debug)('Unable to load RC file');
            (0, logger_1.debug)('Reason: ' + err);
            return { loaded: false };
        }
        throw new error_1.default('Unable to load the ' + constants_1.FILENAME.rc + 'file', {
            exit: 1,
            original: err,
            errorId: 'RC-2',
            arg: [(0, ansi_colors_1.bold)(constants_1.FILENAME.rc)]
        });
    });
    runtime_store_1.default.set('rc', rcInstance);
    if (!rcInstance.loaded) {
        if (!ignoreRC && orgOpt === null && !skipOrgCheck) {
            (0, logger_1.warning)('Not in Catalyst app directory!!!');
            const orgList = yield orgApi.getAllOrgs();
            if (orgList.length === 0) {
                throw new error_1.default('Visit ' +
                    (0, ansi_colors_1.underline)(constants_1.ORIGIN.console) +
                    ' for creation of your first project before you continue.', { exit: 1 });
            }
            const orgChoice = orgList.map((org) => prompt_1.default.choice(org.name + ' (' + org.id + ')', {
                value: org,
                short: org.name
            }));
            const orgAns = yield prompt_1.default.ask(prompt_1.default.question('org', 'Select a Catalyst org to continue: ', {
                type: 'list',
                choices: js_1.JS.reverse(orgChoice),
                when: orgChoice.length > 0
            }));
            const selectedOrg = orgAns.org || orgList[0];
            runtime_store_1.default.set('project.env.id', selectedOrg.id);
        }
        if (optional || ignoreRC) {
            return;
        }
        throw new error_1.default('Not in a Catalyst app directory run catalyst init', {
            exit: 0,
            errorId: 'RC-3',
            arg: [(0, ansi_colors_1.bold)(constants_1.FILENAME.rc), (0, ansi_colors_1.bold)('catalyst init'), (0, ansi_colors_1.bold)('--project')]
        });
    }
    if (ignoreRC) {
        return;
    }
    let finalProjectObj;
    let finalEnvObj;
    if (!(rcInstance instanceof rc_1.default)) {
        throw new error_1.default('RC is undefined', { exit: 2 });
    }
    const defaultRCProject = rcInstance.defaultProject;
    const defaultRCEnv = rcInstance.defaultEnv;
    if (defaultRCProject === undefined || js_1.JS.isEmpty(defaultRCProject)) {
        (0, logger_1.debug)('default project details is not defined or is empty in RC file');
        if (optional) {
            return;
        }
        throw new error_1.default(constants_1.FILENAME.rc + ' file is corrupted', {
            exit: 1,
            errorId: 'RC-4',
            arg: [(0, ansi_colors_1.bold)(constants_1.FILENAME.rc), (0, ansi_colors_1.bold)('catalyst init project'), (0, ansi_colors_1.bold)('--option')]
        });
    }
    if (projectOpt === null) {
        finalProjectObj = rcInstance.activeProject;
        finalEnvObj = rcInstance.activeEnv;
    }
    else if (!isNaN(parseInt(projectOpt, 10))) {
        finalProjectObj = rcInstance.getProjectById(projectOpt);
    }
    else {
        finalProjectObj = rcInstance.getProjectByName(projectOpt);
    }
    if (finalProjectObj === undefined && finalEnvObj === undefined) {
        finalProjectObj = defaultRCProject;
        finalEnvObj = defaultRCEnv;
    }
    if (finalProjectObj === undefined) {
        (0, logger_1.debug)('finalProject came to be empty, default project details is possibly not defined in RC file');
        throw new error_1.default(constants_1.FILENAME.rc + ' file is corrupted', {
            exit: 1,
            errorId: 'RC-4',
            arg: [(0, ansi_colors_1.bold)(constants_1.FILENAME.rc), (0, ansi_colors_1.bold)('catalyst init project'), (0, ansi_colors_1.bold)('--option')]
        });
    }
    if (typeof finalEnvObj !== 'undefined') {
        projectApi = yield (0, endpoints_1.projectAPI)({ auth: true, org: finalEnvObj.id });
        envApi = yield (0, endpoints_1.envAPI)({ auth: true, org: finalEnvObj.id });
    }
    const projectDetails = yield projectApi
        .getProject(finalProjectObj.id + '')
        .catch((err) => __awaiter(void 0, void 0, void 0, function* () {
        if (js_1.JS.hasIn(err, 'context.response.statusCode')) {
            switch (err.context.response.statusCode) {
                case 404: {
                    (0, logger_1.message)('cleaning up ' +
                        constants_1.FILENAME.rc +
                        ' since the current active project for this folder is not found in remote');
                    yield (0, project_2.removeProject)(finalProjectObj.id + '');
                    if (resolveOnNotFound) {
                        finalProjectObj = undefined;
                        return;
                    }
                    throw new error_1.default('active project not found in remote', {
                        exit: 1,
                        errorId: 'RC-5',
                        arg: [(0, ansi_colors_1.bold)('catalyst project:use')]
                    });
                }
                case 403: {
                    const activeDC = (0, dc_1.getActiveDC)();
                    const user = config_store_1.default.get(`${activeDC}.user`);
                    throw new error_1.default('Invalid org identifier: ' + (finalEnvObj === null || finalEnvObj === void 0 ? void 0 : finalEnvObj.id), {
                        original: err,
                        errorId: 'RC-6',
                        arg: [
                            (0, ansi_colors_1.bold)('Current logged in user:'),
                            ansi_colors_1.cyan.italic.underline(user
                                ? user.Email
                                    ? user.Email
                                    : `${user.First_Name} ${user.Last_Name}`
                                : 'unknown user'),
                            (0, ansi_colors_1.bold)('Current Org-id:'),
                            (0, ansi_colors_1.red)((finalEnvObj === null || finalEnvObj === void 0 ? void 0 : finalEnvObj.id) || '')
                        ]
                    });
                }
            }
        }
        throw err;
    }));
    if (projectDetails) {
        if (projectDetails.project_name !== finalProjectObj.name) {
            finalProjectObj.name = projectDetails.project_name;
            finalProjectObj.domain.name = projectDetails.project_domain_details.project_domain_name;
            rcInstance.upsertProject(finalProjectObj);
        }
        if (projectDetails.timezone !== finalProjectObj.timezone) {
            finalProjectObj.timezone = projectDetails.timezone;
            rcInstance.upsertProject(finalProjectObj);
        }
    }
    if (finalProjectObj === undefined) {
        return;
    }
    const envs = (yield envApi.getEnvs(finalProjectObj.id + ''));
    if (finalEnvObj === undefined || js_1.JS.isEmpty(finalEnvObj)) {
        const envObj = js_1.JS.find(envs, { env_name: constants_1.DEFAULT.env_name });
        if (envObj === undefined || js_1.JS.isEmpty(envObj)) {
            throw new error_1.default('Unable to find the development environment for this project', {
                exit: 2
            });
        }
        finalEnvObj = (0, project_2.transformEnv)(envObj);
        yield (0, project_2.upsertEnv)(finalProjectObj.id + '', envObj, {
            active: true,
            base: js_1.JS.isEmpty(defaultRCEnv)
        });
    }
    if (defaultRCProject.id + '' !== finalProjectObj.id + '' &&
        (0, option_1.getCurrentCommand)() !== 'project:reset' &&
        !process.env.CATALYST_SUB_PROCESS) {
        (0, logger_1.message)('Using project other than the default project for this folder. Use ' +
            (0, ansi_colors_1.bold)('catalyst project:reset') +
            ' in order to reset.');
    }
    convertProjectToProperties(finalProjectObj);
    runtime_store_1.default.set('project.env', runtime_store_1.default.get('project.env', finalEnvObj));
});
