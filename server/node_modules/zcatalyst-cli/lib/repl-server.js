'use strict';
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const repl_1 = require("repl");
const util_1 = require("util");
const error_1 = __importDefault(require("./error"));
const stdin = process.stdin;
const ASCII_ETX_CODE = 0x03;
class Repl {
    constructor({ prompt = '>', writer = (output) => (0, util_1.inspect)(output), useColors = true, ignoreUndefined = false } = {}) {
        this.prompt = prompt;
        this.writer = writer;
        this.useColors = useColors;
        this.ignoreUndefined = ignoreUndefined;
        this.server = null;
        this.context = [];
        this.paused = false;
        this.closed = false;
        this.pureEmit = stdin.emit;
    }
    start() {
        this.server = (0, repl_1.start)({
            prompt: this.prompt,
            writer: this.writer,
            useColors: this.useColors,
            ignoreUndefined: this.ignoreUndefined
        });
        this.server.on('reset', () => {
            this.context.forEach((obj) => {
                this.setContext(obj.command, obj.exe);
            });
        });
        this.server.on('message', (print) => {
            this.server.write(print.join('\n'));
        });
        return this;
    }
    emit(eventName, ...inputs) {
        if (this.server === null) {
            throw new error_1.default('emit cannot be called before server is started', { exit: 2 });
        }
        return this.server.emit(eventName, inputs);
    }
    showPrompt() {
        if (this.server === null) {
            throw new error_1.default('showPrompt cannot be called before server is started', {
                exit: 2
            });
        }
        if (!this.closed) {
            this.server.displayPrompt();
        }
    }
    setContext(command, exe) {
        if (this.server === null) {
            throw new error_1.default('context cannot be set before server is started', { exit: 2 });
        }
        const context = this.server.context;
        this.context.push({ command, exe });
        Object.defineProperty(context, command, {
            configurable: false,
            value: exe
        });
        return this;
    }
    close() {
        if (this.server === null) {
            throw new error_1.default('close cannot be called before server is started', { exit: 2 });
        }
        this.server.close();
    }
    pause() {
        if (this.paused) {
            return;
        }
        this.pureEmit = stdin.emit;
        stdin.emit = (event, ...args) => {
            if (event === 'keypress') {
                return true;
            }
            if (event === 'data' && args[0].includes(ASCII_ETX_CODE)) {
                this.resume();
                this.close();
            }
            return true;
        };
        this.paused = true;
    }
    resume() {
        if (this.paused) {
            stdin.emit = this.pureEmit;
        }
        this.paused = false;
    }
    wait() {
        return new Promise((res) => {
            if (this.server === null) {
                throw new error_1.default('wait cannot be called before server is started', {
                    exit: 2
                });
            }
            this.server.on('close', () => {
                this.resume();
                this.closed = true;
                res();
            });
        });
    }
}
exports.default = Repl;
