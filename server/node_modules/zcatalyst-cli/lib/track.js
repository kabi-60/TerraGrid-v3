'use strict';
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = require("path");
const readline_1 = require("readline");
const config_store_1 = __importDefault(require("./config-store"));
const endpoints_1 = require("./endpoints");
const error_1 = __importDefault(require("./error"));
const runtime_store_1 = __importDefault(require("./runtime-store"));
const fs_1 = require("./util_modules/fs");
const logger_1 = require("./util_modules/logger");
const winston_1 = require("./winston");
exports.default = (event, message, duration) => __awaiter(void 0, void 0, void 0, function* () {
    (0, logger_1.debug)(`EXEC ENDED with event: ${event}, message: ${message}`);
    (0, logger_1.debug)('TOTAL DURATION OF COMMAND EXEC : ' + duration);
    try {
        const httpLog = winston_1.logger.transports.find((transport) => {
            return (transport.filename ===
                winston_1.transport.http_log.filename);
        });
        if (runtime_store_1.default.get('credential', false) &&
            config_store_1.default.get('usage', false) &&
            httpLog !== undefined) {
            const httpLogger = yield (0, endpoints_1.logAPI)();
            if (httpLogger === undefined) {
                (0, logger_1.debug)('Unable to initialise the log API');
                return;
            }
            winston_1.logger.remove(httpLog);
            const rl = (0, readline_1.createInterface)({
                input: fs_1.SYNC.getReadStream((0, path_1.join)(httpLog.dirname, httpLog.filename)),
                crlfDelay: Infinity
            });
            const logInput = yield new Promise((resolve) => {
                const logArr = [];
                rl.on('line', (ln) => {
                    logArr.push(JSON.parse(ln));
                }).on('close', () => {
                    resolve(logArr);
                });
            });
            yield httpLogger.log(logInput);
        }
    }
    catch (e) {
        const err = error_1.default.getErrorInstance(e);
        (0, logger_1.debug)('Unable to send debug log to server: ' + err.message);
    }
});
