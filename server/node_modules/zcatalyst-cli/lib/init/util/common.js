"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getRuntimePromptAnswer = exports.getRuntimeChoices = exports.getRuntimeDetails = void 0;
const catalyst_details_js_1 = __importDefault(require("../../endpoints/lib/catalyst-details.js"));
const error_js_1 = __importDefault(require("../../error.js"));
const index_js_1 = __importDefault(require("../../prompt/index.js"));
const char_1 = require("../../util_modules/char");
const index_js_2 = require("../../util_modules/constants/index.js");
const logger_js_1 = require("../../util_modules/logger.js");
function getRuntimeDetails(fnType) {
    const catalystDetailsAPI = new catalyst_details_js_1.default();
    return catalystDetailsAPI.getDetails('runtime', fnType ? index_js_2.REMOTE_REF.functions.type[fnType] : undefined);
}
exports.getRuntimeDetails = getRuntimeDetails;
function getRuntimeChoices({ fnType, runtimeDetails }) {
    return __awaiter(this, void 0, void 0, function* () {
        if (runtimeDetails === undefined) {
            runtimeDetails = yield getRuntimeDetails(fnType);
        }
        const runtimeChoices = runtimeDetails.runtimes.reduce((acc, value) => {
            const langArr = value.match(/^([a-zA-Z]+)([0-9_]+)$/);
            const runtimeLang = langArr !== null
                ? index_js_2.RUNTIME.language[langArr[1]]
                : undefined;
            if (!langArr || !runtimeLang) {
                (0, logger_js_1.debug)('Language cannot be identified hence skipping');
                return acc;
            }
            const langV = langArr[2].split('_');
            let displayValue = runtimeLang.label +
                ' ' +
                (langV.length === 1 ? langV[0] : langV.slice(1).join('.'));
            let disabled = false;
            if ((runtimeDetails === null || runtimeDetails === void 0 ? void 0 : runtimeDetails.eol_runtimes) && runtimeDetails.eol_runtimes[value]) {
                switch (runtimeDetails.eol_runtimes[value]) {
                    case 1:
                        displayValue += ` (${char_1.CHAR.info} This runtime has reached its EOL)`;
                        break;
                    case 2:
                        displayValue += ` (${char_1.CHAR.warning} Only updates are allowed in this runtime)`;
                        disabled = true;
                        break;
                    case 3:
                        displayValue += ` (${char_1.CHAR.error} This runtime is no longer supported)`;
                        disabled = true;
                        break;
                    default:
                        (0, logger_js_1.debug)('unknown eol_runtime value ' + runtimeDetails.eol_runtimes[value]);
                        return acc;
                }
            }
            if (acc[runtimeLang.value].length === 0) {
                const sep = {
                    node: '---NodeJS---',
                    java: '----Java----',
                    python: '---Python---'
                };
                acc[runtimeLang.value].push(index_js_1.default.separator(sep[runtimeLang.value]));
            }
            acc[runtimeLang.value].push(index_js_1.default.choice(displayValue, {
                value: { runtime: value, lang: runtimeLang.value },
                short: displayValue,
                disabled
            }));
            return acc;
        }, {
            node: [],
            java: [],
            python: []
        });
        return [...runtimeChoices.java, ...runtimeChoices.node, ...runtimeChoices.python];
    });
}
exports.getRuntimeChoices = getRuntimeChoices;
function getRuntimePromptAnswer(question, fnType) {
    return __awaiter(this, void 0, void 0, function* () {
        const runtimeChoices = yield getRuntimeChoices({ fnType });
        const runtimeAns = yield index_js_1.default.ask(index_js_1.default.question('runtime', question, {
            type: 'list',
            choices: runtimeChoices,
            when: () => {
                return runtimeChoices.length > 1;
            }
        }));
        if (runtimeAns === undefined || runtimeAns.runtime === undefined) {
            throw new error_js_1.default('Selected runtime is invalid.', { exit: 2 });
        }
        return runtimeAns.runtime;
    });
}
exports.getRuntimePromptAnswer = getRuntimePromptAnswer;
