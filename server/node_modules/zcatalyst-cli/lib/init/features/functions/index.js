'use strict';
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ansi_colors_1 = require("ansi-colors");
const integ_1 = require("../../../fn-utils/lib/integ");
const prompt_1 = __importDefault(require("../../../prompt"));
const runtime_store_1 = __importDefault(require("../../../runtime-store"));
const constants_1 = require("../../../util_modules/constants");
const fs_1 = require("../../../util_modules/fs");
const logger_1 = require("../../../util_modules/logger");
const option_1 = require("../../../util_modules/option");
const project_1 = require("../../../util_modules/project");
const common_1 = require("../../util/common");
const languages_1 = __importDefault(require("./languages"));
const catalyst_details_1 = __importDefault(require("../../../endpoints/lib/catalyst-details"));
exports.default = () => __awaiter(void 0, void 0, void 0, function* () {
    const currentCmd = (0, option_1.getCurrentCommand)();
    const config = runtime_store_1.default.get('config');
    const functionsDirPath = (0, project_1.resolveProjectPath)(config.get('functions.source') || constants_1.FOLDERNAME.functions);
    const catalystDetailsAPI = new catalyst_details_1.default();
    const integServicesPromise = catalystDetailsAPI
        .getDetails('integration_services')
        .catch((err) => (0, logger_1.debug)('Error feting integ services: ', err));
    runtime_store_1.default.set('context.functions.dir_path', functionsDirPath);
    if (currentCmd === 'init' || currentCmd === 'functions:setup') {
        (0, logger_1.message)('A directory ' +
            ansi_colors_1.cyan.bold(constants_1.FOLDERNAME.functions) +
            ' will be created with a catalyst function pre-configured.\n');
        const folderExits = yield fs_1.ASYNC.dirExists(functionsDirPath);
        const overwriteAns = folderExits
            ? yield prompt_1.default.ask(prompt_1.default.question('overwrite', 'Directory ' +
                (0, ansi_colors_1.underline)(constants_1.FOLDERNAME.functions) +
                ' already exists. Overwrite ?', {
                type: 'confirm',
                defaultAns: false
            }))
            : { overwrite: true };
        if (!overwriteAns.overwrite) {
            (0, logger_1.warning)('skipping function setup');
            return;
        }
        yield fs_1.ASYNC.deleteDir(functionsDirPath).catch();
    }
    const fnTypeChoices = [
        prompt_1.default.choice('BasicIO', {
            value: constants_1.FN_TYPE.basic,
            short: 'basicIO'
        }),
        prompt_1.default.choice('AdvancedIO', {
            value: constants_1.FN_TYPE.advanced,
            short: 'advancedIO'
        }),
        prompt_1.default.choice('Event', {
            value: constants_1.FN_TYPE.event,
            short: 'event'
        }),
        prompt_1.default.choice('Cron', {
            value: constants_1.FN_TYPE.cron,
            short: 'cron'
        }),
        prompt_1.default.choice('Browser Logic', {
            value: constants_1.FN_TYPE.browserLogic,
            short: 'browser logic'
        })
    ];
    const integServicesRes = yield integServicesPromise;
    const integServices = integServicesRes === null || integServicesRes === void 0 ? void 0 : integServicesRes.integration_services;
    if (integServices && integServices.length > 0) {
        fnTypeChoices.push(prompt_1.default.choice('Integration', {
            value: constants_1.FN_TYPE.integration,
            short: 'integration'
        }));
    }
    const fnTypeAns = yield prompt_1.default.ask(prompt_1.default.question('type', 'Which type of function do you like to create?', {
        type: 'list',
        choices: fnTypeChoices
    }));
    runtime_store_1.default.set('context.functions.type', fnTypeAns.type);
    if (fnTypeAns.type === constants_1.FN_TYPE.integration && integServices) {
        yield (0, integ_1.integHelper)(integServices);
    }
    const runtimeAns = yield (0, common_1.getRuntimePromptAnswer)('Which runtime do you prefer to write your function?', fnTypeAns.type);
    return languages_1.default[runtimeAns.lang](runtimeAns.runtime)();
});
