'use strict';
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.installPkgs = exports.installRequirements = exports.pypiRes = exports.ensurePyRuntime = void 0;
const error_1 = __importDefault(require("../../../error"));
const prompt_1 = __importDefault(require("../../../prompt"));
const shell_1 = require("../../../util_modules/shell");
const constants_1 = require("../../../util_modules/constants");
const path_1 = require("path");
const fs_1 = require("../../../util_modules/fs");
const https_1 = __importDefault(require("https"));
const runtime_1 = __importDefault(require("../../../util_modules/constants/lib/runtime"));
const env_1 = require("../../../util_modules/env");
const ensure_python_1 = require("./ensure-python");
const userConfig_1 = __importDefault(require("../../../userConfig"));
const logger_1 = require("../../../util_modules/logger");
const sdkPipOpts = (0, env_1.envOverride)('CATALYST_SDK_PIP_OPTS', 'zcatalyst-sdk');
const cliqSdkPipOpts = (0, env_1.envOverride)('CATALYST_CLIQ_SDK_PIP_OPTS', 'zcatalyst-cliq');
const testPypi = (0, env_1.envOverride)('CATALYST_TEST_PYPI', 'false');
exports.default = (pth, stack, isIntegFn = false, integService = false) => __awaiter(void 0, void 0, void 0, function* () {
    const stackVersion = stack.replace('python_', '');
    const ans = yield prompt_1.default.ask(prompt_1.default.question('pipInstall', 'Do you wish to install all dependency libraries now ? ', {
        type: 'confirm',
        defaultAns: true,
        when: () => !isIntegFn
    }));
    if (ans.pipInstall && !isIntegFn) {
        yield (0, ensure_python_1.ensurePythonWithPip)(stackVersion.replace('_', '.'), true);
        const spawnOpts = ['-m', 'pip', 'install', ...sdkPipOpts.split(' '), '-t', '.'];
        return (0, shell_1.spawn)(userConfig_1.default.get(`python${stackVersion}.bin`), spawnOpts, {
            cwd: pth
        })
            .ASYNC()
            .catch((err) => {
            throw new error_1.default('Failure while installing zcatalyst SDk', {
                exit: 2,
                original: err
            });
        });
    }
    else if ((isIntegFn || ans.pipInstall === undefined) &&
        integService === constants_1.INTEG.services.cliq) {
        yield (0, ensure_python_1.ensurePythonWithPip)(stackVersion.replace('_', '.'), true);
        const spawnOpts = ['-m', 'pip', 'install', ...cliqSdkPipOpts.split(' '), '-t', '.'];
        return (0, shell_1.spawn)(userConfig_1.default.get(`python${stackVersion}.bin`), spawnOpts, { cwd: pth })
            .ASYNC()
            .catch((err) => {
            throw error_1.default.getErrorInstance(err, {
                message: 'Failure while installing zcatalyst cliq SDK.'
            });
        });
    }
});
function ensurePyRuntime(pth, stack) {
    return __awaiter(this, void 0, void 0, function* () {
        const stackVersion = stack.replace('python_', '');
        const runtimePkgName = 'zcatalyst-runtime-' + stackVersion.replace('_', '');
        yield fs_1.ASYNC.ensureDir(pth);
        const runtimeDir = (0, path_1.join)(pth, runtime_1.default.language.python.value, `zcatalyst_runtime_${stackVersion.replace('_', '')}`);
        const isInitializerExists = yield fs_1.ASYNC.fileExists((0, path_1.join)(runtimeDir, 'main.py'));
        if (isInitializerExists) {
            const runtimeMetaData = yield fs_1.ASYNC.readJSONFile((0, path_1.join)(runtimeDir, 'meta.json'));
            const pyRespJson = yield (0, exports.pypiRes)(runtimePkgName);
            if ((runtimeMetaData === null || runtimeMetaData === void 0 ? void 0 : runtimeMetaData.version) === pyRespJson.info.version) {
                return;
            }
        }
        yield new Promise((resolve, reject) => {
            var _a;
            const spawnOpts = ['-m', 'pip', 'install', runtimePkgName, '--upgrade', '-t', './python'];
            if (testPypi === 'true') {
                spawnOpts.push('-i', 'https://test.pypi.org/simple/', '--extra-index-url', 'https://pypi.org/simple/');
            }
            const child = (0, shell_1.spawn)(userConfig_1.default.get(`python${stackVersion}.bin`), spawnOpts, {
                cwd: pth,
                stdio: 'pipe'
            }).RAW();
            const errData = [];
            (_a = child.stderr) === null || _a === void 0 ? void 0 : _a.on('data', (chunk) => {
                errData.push(chunk);
            });
            child.on('error', (err) => {
                (0, logger_1.info)(Buffer.concat(errData).toString());
                reject(new error_1.default(`Error while installing python${stackVersion.replace('_', '.')} runtime`, {
                    original: err,
                    exit: 2
                }));
            });
            child.on('exit', (code) => {
                if (code !== 0) {
                    process.stderr.write(Buffer.concat(errData).toString());
                    reject(new error_1.default(`Error while installing python${stackVersion.replace('_', '.')} runtime`, {
                        exit: 1
                    }));
                }
                resolve();
            });
        });
        try {
            const runtimeReqFile = (0, path_1.join)(runtimeDir, constants_1.FILENAME.functions.python_requirements);
            if (yield fs_1.ASYNC.fileExists(runtimeReqFile)) {
                yield installRequirements(runtimeReqFile, runtimeDir, stackVersion);
            }
        }
        catch (err) {
            yield fs_1.ASYNC.deleteDir(runtimeDir);
            throw new error_1.default(`Error while installing python${stackVersion.replace('_', '.')} runtime dependencies`);
        }
    });
}
exports.ensurePyRuntime = ensurePyRuntime;
const pypiRes = (pkg) => __awaiter(void 0, void 0, void 0, function* () {
    const url = testPypi === 'true'
        ? `https://test.pypi.org/pypi/${pkg}/json`
        : `https://pypi.org/pypi/${pkg}/json`;
    return new Promise((res) => {
        https_1.default
            .get(url, (resp) => {
            const resBuffer = [];
            resp.on('data', (chunk) => {
                resBuffer.push(chunk);
            });
            resp.on('end', () => {
                res(JSON.parse(Buffer.concat(resBuffer).toString()));
            });
        })
            .on('error', (e) => {
            throw new error_1.default('Error getting latest runtime version', {
                original: e,
                exit: 2
            });
        });
    });
});
exports.pypiRes = pypiRes;
function installRequirements(reqFile, pth, stackVersion, linuxMode = false) {
    return __awaiter(this, void 0, void 0, function* () {
        const spawnOpts = ['-m', 'pip', 'install', '-r', reqFile, '-t', '.', '--upgrade'];
        if (linuxMode) {
            spawnOpts.push(...[
                '--platform',
                'manylinux2014_x86_64',
                '--implementation',
                'cp',
                '--only-binary=:all:'
            ]);
        }
        if (testPypi === 'true') {
            spawnOpts.push('-i', 'https://test.pypi.org/simple/', '--extra-index-url', 'https://pypi.org/simple/');
        }
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            var _a;
            const child = (0, shell_1.spawn)(userConfig_1.default.get(`python${stackVersion}.bin`), spawnOpts, {
                cwd: pth,
                stdio: 'pipe'
            }).RAW();
            const errData = [];
            (_a = child.stderr) === null || _a === void 0 ? void 0 : _a.on('data', (chunk) => {
                errData.push(chunk);
            });
            child.on('error', (err) => {
                (0, logger_1.info)(Buffer.concat(errData).toString());
                reject(new error_1.default('unable to process requirements.txt', {
                    exit: 2,
                    original: err
                }));
            });
            child.on('exit', (code) => {
                if (code !== 0) {
                    process.stderr.write(Buffer.concat(errData).toString());
                    reject(new error_1.default('unable to process requirements.txt', {
                        exit: 1,
                        skipHelp: true
                    }));
                }
                resolve();
            });
        }));
    });
}
exports.installRequirements = installRequirements;
function installPkgs(pkgs, stackVersion, pth = undefined) {
    return __awaiter(this, void 0, void 0, function* () {
        const spawnOpts = ['-m', 'pip', 'install', ...pkgs, '--upgrade'];
        if (pth) {
            spawnOpts.push(...['-t', pth]);
        }
        return (0, shell_1.spawn)(userConfig_1.default.get(`python${stackVersion}.bin`), spawnOpts, {
            cwd: pth,
            stdio: 'ignore'
        })
            .ASYNC()
            .catch((err) => {
            throw error_1.default.getErrorInstance(err, {
                message: `unable to install the package - ${pkgs.join(',')}`,
                skipHelp: true
            });
        });
    });
}
exports.installPkgs = installPkgs;
