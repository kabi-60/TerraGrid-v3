'use strict';
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.executeCommand = void 0;
const ansi_colors_1 = require("ansi-colors");
const error_1 = __importDefault(require("./error"));
const runtime_store_1 = __importDefault(require("./runtime-store"));
const config = __importStar(require("./util_modules/config"));
const constants_1 = require("./util_modules/constants");
const env_1 = require("./util_modules/env");
const js_1 = require("./util_modules/js");
const logger_1 = require("./util_modules/logger");
const project_1 = require("./util_modules/project");
const shell_1 = require("./util_modules/shell");
function executeCommand(exeCommand, { moduleSource, feature }) {
    const cwd = moduleSource || runtime_store_1.default.get('project.root');
    const exeDir = (0, project_1.resolveProjectPath)(cwd);
    (0, logger_1.info)();
    (0, logger_1.info)(`Executing ${(0, ansi_colors_1.cyan)(feature)} script in ${(0, ansi_colors_1.underline)(exeDir)}`);
    (0, logger_1.debug)('Executing command > ' + exeCommand);
    (0, logger_1.info)(`> ${exeCommand}`);
    const exitListeners = process.listeners('exit');
    process.removeAllListeners('exit');
    const result = (0, shell_1.spawn)(exeCommand, [], {
        cwd: exeDir,
        shell: true,
        stdio: 'inherit'
    }).SYNC();
    if ((0, env_1.isPrimaryShell)()) {
        js_1.JS.forEach(exitListeners || [], (listener) => {
            process.addListener('exit', listener);
        });
    }
    if (result.status === null || result.status > 0 || result.error) {
        throw new error_1.default('The script exited with code greater than 0 or an error', {
            exit: 0,
            original: new Error(JSON.stringify(result)),
            errorId: 'EXEC-SCRIPT-4',
            arg: [(0, ansi_colors_1.bold)(feature), ansi_colors_1.italic.red(JSON.stringify(result, null, '  '))]
        });
    }
    return result;
}
exports.executeCommand = executeCommand;
exports.default = (commandName) => {
    const featureByScript = commandName.split(':');
    if (featureByScript.length !== 2) {
        throw new error_1.default('Not a proper script command', {
            exit: 1,
            errorId: 'EXEC-SCRIPT-1',
            arg: [ansi_colors_1.bold.red(commandName), (0, ansi_colors_1.bold)('feature:script')]
        });
    }
    const configModule = config[(featureByScript[0] + 'Config')];
    if (configModule === undefined) {
        throw new error_1.default('Not a valid catayst feature', {
            exit: 1,
            errorId: 'EXEC-SCRIPT-2',
            arg: [
                (0, ansi_colors_1.bold)(commandName.replace(featureByScript[0], (0, ansi_colors_1.red)(featureByScript[0]))),
                (0, ansi_colors_1.bold)(['* client', '* function'].join('\n'))
            ]
        });
    }
    const exeTempCommand = configModule.script(featureByScript[1], null);
    if (exeTempCommand === null) {
        const availableScripts = configModule.script(undefined, false);
        throw new error_1.default(featureByScript[1] + ' script is not available.', {
            exit: 1,
            errorId: 'EXEC-SCRIPT-3',
            arg: [
                ansi_colors_1.bold.red(featureByScript[1]),
                (0, ansi_colors_1.bold)(constants_1.FILENAME.config),
                (0, ansi_colors_1.bold)(availableScripts
                    ? Object.keys(availableScripts)
                        .map((script) => '* ' + script)
                        .join('\n')
                    : '* None')
            ]
        });
    }
    const featureSource = (0, project_1.resolveProjectPath)(configModule.source());
    const exeCommand = js_1.JS.chain(exeTempCommand)
        .split(' ')
        .map((arg) => {
        if (arg.includes('${source}')) {
            return arg.replace('${source}', featureSource);
        }
        return arg;
    })
        .join(' ')
        .value();
    return executeCommand(exeCommand, {
        moduleSource: configModule.source(),
        feature: featureByScript[1]
    });
};
